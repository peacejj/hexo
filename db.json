{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/file/goujian.pdf","path":"file/goujian.pdf","modified":0,"renderable":0},{"_id":"source/images/dark.jpeg","path":"images/dark.jpeg","modified":0,"renderable":0},{"_id":"source/img/default.png","path":"img/default.png","modified":0,"renderable":0},{"_id":"source/images/angular/DI.png","path":"images/angular/DI.png","modified":0,"renderable":0},{"_id":"source/images/angular/service.png","path":"images/angular/service.png","modified":0,"renderable":0},{"_id":"source/images/net/dns.png","path":"images/net/dns.png","modified":0,"renderable":0},{"_id":"source/images/rxjs/clipboard.png","path":"images/rxjs/clipboard.png","modified":0,"renderable":0},{"_id":"source/images/rxjs/clipboard2.png","path":"images/rxjs/clipboard2.png","modified":0,"renderable":0},{"_id":"source/images/rxjs/clipboard3.png","path":"images/rxjs/clipboard3.png","modified":0,"renderable":0},{"_id":"source/images/banner/bg1.jpg","path":"images/banner/bg1.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg.jpg","path":"images/banner/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg2.jpg","path":"images/banner/bg2.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg3.jpg","path":"images/banner/bg3.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/about.jpg","path":"images/banner/about.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg4.jpg","path":"images/banner/bg4.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg5.jpg","path":"images/banner/bg5.jpg","modified":0,"renderable":0},{"_id":"source/images/banner/bg6.jpg","path":"images/banner/bg6.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/anchor.md","hash":"eef6c5be5ed1a29e5b7c89ee22a9885a560c95c6","modified":1620633290605},{"_id":"source/_posts/angular-di.md","hash":"a8722fb1c7d0ee2c39cac61dd66dc28ed907416c","modified":1620638602772},{"_id":"source/_posts/ChangeDetectorRef.md","hash":"8a1f78ed042fe9e337ee99199e840c4f7fa8b283","modified":1620637570696},{"_id":"source/_posts/angular-custom-form.md","hash":"c8b7569fc6e5947a707c899836a1f5f8026fdf94","modified":1620638948268},{"_id":"source/_posts/angular-service.md","hash":"b6f29fa900da49d3ef0a3cbfc96332d6e418b5e5","modified":1620638164270},{"_id":"source/_posts/async-schedule.md","hash":"aa365a90b27f2d76d86014f5ab6cc3ad0c12eeb5","modified":1620715518425},{"_id":"source/_posts/angular-translate.md","hash":"337f9227b50a935716275f1ec3f22c525f161122","modified":1620639194152},{"_id":"source/_posts/backflow-and-redraw.md","hash":"48fb500fe00f69bffce5adbf3c935118aa003c5f","modified":1620629900070},{"_id":"source/_posts/build-tools.md","hash":"a9a6f8dcd7f77876f4c7c8ef8eeca6aecadb70e4","modified":1620460038127},{"_id":"source/_posts/css-animation.md","hash":"760b72149a6369048d950b3d4ee44d3b276b0712","modified":1620632076528},{"_id":"source/_posts/babel-loader.md","hash":"2f1c555ee1a486e9a2972e1ff4f43b76befe87cc","modified":1620634198578},{"_id":"source/_posts/compare.md","hash":"7ad47453cb49276057c2a0e13294a34e84572d43","modified":1620698249672},{"_id":"source/_posts/css-line.md","hash":"7bd8e169d97fc97e6ad1cd7b8807397a9449ff79","modified":1620632414860},{"_id":"source/_posts/dns.md","hash":"bc2f0fef2f141285a8cf6b86bad3cae1322ea142","modified":1620701197687},{"_id":"source/_posts/generator.md","hash":"a1c2dd0d9e884b1d031f65b2de321afe45100d4c","modified":1620698249695},{"_id":"source/_posts/css-width.md","hash":"07add7ffcb7ce9b047c9f0ff6c8dddcd5e7def00","modified":1620629701807},{"_id":"source/_posts/happyPack.md","hash":"864463cad0304eb9db0f50a9b172e220d7a2f99e","modified":1620466555173},{"_id":"source/_posts/jwt.md","hash":"dcfb1dba9bee06fd4bb4d3deb5bd6579a04dc0c5","modified":1620637733054},{"_id":"source/_posts/dom-parese.md","hash":"31bbf21efc68e2501d3948c0c5afe887bee877d4","modified":1620700700042},{"_id":"source/_posts/input-autocomplete.md","hash":"e2dccec60dad85b116db506d7ba7faac0b1b712b","modified":1620633002676},{"_id":"source/_posts/package.md","hash":"753eeb6ea36e9a44c9575c04ca07855b6348cd51","modified":1620639376807},{"_id":"source/_posts/linux01.md","hash":"d7422b2d7d346ed2503f8dbc141e93eabb996098","modified":1620467119082},{"_id":"source/_posts/weakSet.md","hash":"7b557c0e99dce3dde8af97a7e375f4eb181d8396","modified":1620698249703},{"_id":"source/_posts/module.md","hash":"7ae598c0249f17e0703036cc083675405ebf4244","modified":1620698249684},{"_id":"source/_posts/ssh.md","hash":"f1aada02b4f6f0fb0b63d2fb38cc22999b5c5121","modified":1620460143882},{"_id":"source/_posts/webpack-analyzer.md","hash":"5dbfe51eea4e869a4bf4c56ff1fceaef7c8c0410","modified":1620635622228},{"_id":"source/_posts/subscribe.md","hash":"7d80f11c49f9716ca9926804c5ca05393db16490","modified":1620699539684},{"_id":"source/_posts/rxjs.md","hash":"4b740e76085640031a3580078412d940390566ff","modified":1620637055571},{"_id":"source/images/about.jpg","hash":"e21d9af10e2de28a342c2fbc98930a1f55fd23d2","modified":1620715862290},{"_id":"source/tags/index.md","hash":"d952fb385bf441f3f406133f9ccf849de8ea9cd7","modified":1620701972196},{"_id":"source/guestbook/index.md","hash":"950525c85c5d2625fbf11dd3174b5d7dae72f8b7","modified":1620702823809},{"_id":"source/about/index.md","hash":"3f66cc0478497e093bdb7e800b6d91451a2dc655","modified":1620719005522},{"_id":"source/_posts/webpack-custom-plugin.md","hash":"d4284487aecc0703404316564ce120401d145d9e","modified":1620635562867},{"_id":"source/img/default.png","hash":"9f252e51d2e2ec0b0f7a743ba50d9b3d7d46e913","modified":1620712394946},{"_id":"source/images/angular/DI.png","hash":"5f219610f6a14105bd8ea05264ca3fa225d6f624","modified":1612163151702},{"_id":"source/images/angular/service.png","hash":"222e204bc86e6c212d22e6ded976f4a5172e29f8","modified":1596538884061},{"_id":"source/images/rxjs/clipboard2.png","hash":"0653ecbcd539f74c5a2c863c03b451ce0a2726ff","modified":1589954644720},{"_id":"source/images/dark.jpeg","hash":"0cc76cab7dcca7efe66a20a29add18b8f1975e46","modified":1620352266613},{"_id":"source/images/net/dns.png","hash":"774edd491a72295b0fa85d304db1603c0fbe8f53","modified":1618301646795},{"_id":"source/images/rxjs/clipboard.png","hash":"a6a56c93c311d44cc0eaa3dfb7bffd39731b006d","modified":1589944310274},{"_id":"source/images/rxjs/clipboard3.png","hash":"8f7162849570151c5f03474bbcfa6bbdc4bfe18f","modified":1587524998648},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"11b11f4b2d8efc90549cbfa766e0d669bf158e2f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"caab17708ba7383ee1f7cdbb7e2cfc017d8862f9","modified":1620704788571},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"248ecd01aead6e07ac1904a7b7c45395a922bcc7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"a2b4d8b1ce866c5dda350887c3fad6d3a5426f70","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"569642bb89610c3c0f1827b1b6dff90571ec4879","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f7fd69496ffc156cc1c224fb8d26c46d5b437425","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"702cd88097274924971292c042ae4955999c3a4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d1aef2da328e10dadcd403eaea95d6f6e4665622","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"ae5685ce20424d1c3c9b2cd983ed5f80a81b7002","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"1ff78b48faa3a7ea0b3a649a2632adc8cc65b79b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"0b158c7e0cf630261271fce4a685698c5b14580a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"7d85b7466ac3c38a826c25418d8408fa561ec6da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"497801aca43854e0bcb8092166752291a8e17c36","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"afe18734fc52e31fb7b6e0b5360aa936007ec22f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"6cbd241656c688fb37ca2627caf7969b7854de25","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"c8b29cf71176a2f36b5b06a4befdbd405c42fbd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"d6f4ecb8a965ad86295f211081e7bb6c00af7737","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"2366bd7cf64735a140d730c8efae83734cc36acf","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/file/goujian.pdf","hash":"e88c2e27e1467ac8e7341a06955408e31619117d","modified":1620447751087},{"_id":"source/images/banner/bg1.jpg","hash":"d057822fa0562829c8611fe6d18e82d471bf804f","modified":1620718286887},{"_id":"source/images/banner/bg.jpg","hash":"ac3c8662304f3aa06a878e31bb15c2f88c4e15e3","modified":1620718158491},{"_id":"source/images/banner/bg2.jpg","hash":"26a557e49e082988de6adb20e01da06000b574ad","modified":1620718838546},{"_id":"source/images/banner/about.jpg","hash":"e21d9af10e2de28a342c2fbc98930a1f55fd23d2","modified":1620715862290},{"_id":"source/images/banner/bg3.jpg","hash":"7830246d1a2a9f747a235faa50198ad74f0a43a9","modified":1620718920049},{"_id":"source/images/banner/bg4.jpg","hash":"014457799d5be9ceac86bb2d31f6e825874e1968","modified":1620720376030},{"_id":"source/images/banner/bg5.jpg","hash":"a805d1d57689211ba752a407457a87ac47914e6c","modified":1620719762319},{"_id":"source/images/banner/bg6.jpg","hash":"134fde9caaae9f1a57e4dc238c4098b29c8236a4","modified":1620720430720}],"Category":[{"name":"项目相关","_id":"ckojojkmx000e1kwa12u19gig"}],"Data":[],"Page":[{"title":"关于我","date":"2021-05-10T07:50:53.000Z","layout":"about","comment":"valine","_content":"\n<div class=\"about\">\n    <p>这是一段自我介绍:</p>\n    <p>我是一个靠写代码过日子的人</p>\n    <p>前端，前端，前端</p>\n    <p>喜欢音乐、猫、科幻、王者峡谷、追权志龙</p>\n    <p>会在此博客放一些自己写的代码</p>\n    <p>和一些自己胡言乱语</p>\n</div>\n<div class=\"about\">\n    <p>喜欢的一首诗《过节》送给大家</p>\n    <p>作者：北岛</p>\n    <p>毒蛇炫耀口中的钉子</p>\n    <p>大地有著毒蛇</p>\n    <p>吞吃鸟蛋的寂静</p>\n    <p>所有钟表</p>\n    <p>停止在无梦的时刻</p>\n    <p>丰收聚敛着</p>\n    <p>田野死后的笑容</p>\n    <p>从水银的镜子出发</p>\n    <p>影像成双的人们</p>\n    <p>乘家庭的轮子</p>\n    <p>去集市</p>\n    <p>一位本地英雄</p>\n    <p>在废弃的停车场上</p>\n    <p>唱歌</p>\n    <p>玻璃晴朗</p>\n    <p>桔子辉煌</p>\n</div>\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2021-05-10 15:50:53\nlayout: about\ncomment: 'valine'\n---\n\n<div class=\"about\">\n    <p>这是一段自我介绍:</p>\n    <p>我是一个靠写代码过日子的人</p>\n    <p>前端，前端，前端</p>\n    <p>喜欢音乐、猫、科幻、王者峡谷、追权志龙</p>\n    <p>会在此博客放一些自己写的代码</p>\n    <p>和一些自己胡言乱语</p>\n</div>\n<div class=\"about\">\n    <p>喜欢的一首诗《过节》送给大家</p>\n    <p>作者：北岛</p>\n    <p>毒蛇炫耀口中的钉子</p>\n    <p>大地有著毒蛇</p>\n    <p>吞吃鸟蛋的寂静</p>\n    <p>所有钟表</p>\n    <p>停止在无梦的时刻</p>\n    <p>丰收聚敛着</p>\n    <p>田野死后的笑容</p>\n    <p>从水银的镜子出发</p>\n    <p>影像成双的人们</p>\n    <p>乘家庭的轮子</p>\n    <p>去集市</p>\n    <p>一位本地英雄</p>\n    <p>在废弃的停车场上</p>\n    <p>唱歌</p>\n    <p>玻璃晴朗</p>\n    <p>桔子辉煌</p>\n</div>\n\n","updated":"2021-05-11T07:43:25.522Z","path":"about/index.html","_id":"ckojojkmc00001kwa1plrd1tc","comments":1,"content":"<div class=\"about\">\n    <p>这是一段自我介绍:</p>\n    <p>我是一个靠写代码过日子的人</p>\n    <p>前端，前端，前端</p>\n    <p>喜欢音乐、猫、科幻、王者峡谷、追权志龙</p>\n    <p>会在此博客放一些自己写的代码</p>\n    <p>和一些自己胡言乱语</p>\n</div>\n<div class=\"about\">\n    <p>喜欢的一首诗《过节》送给大家</p>\n    <p>作者：北岛</p>\n    <p>毒蛇炫耀口中的钉子</p>\n    <p>大地有著毒蛇</p>\n    <p>吞吃鸟蛋的寂静</p>\n    <p>所有钟表</p>\n    <p>停止在无梦的时刻</p>\n    <p>丰收聚敛着</p>\n    <p>田野死后的笑容</p>\n    <p>从水银的镜子出发</p>\n    <p>影像成双的人们</p>\n    <p>乘家庭的轮子</p>\n    <p>去集市</p>\n    <p>一位本地英雄</p>\n    <p>在废弃的停车场上</p>\n    <p>唱歌</p>\n    <p>玻璃晴朗</p>\n    <p>桔子辉煌</p>\n</div>\n\n","site":{"data":{}},"excerpt":"","more":"<div class=\"about\">\n    <p>这是一段自我介绍:</p>\n    <p>我是一个靠写代码过日子的人</p>\n    <p>前端，前端，前端</p>\n    <p>喜欢音乐、猫、科幻、王者峡谷、追权志龙</p>\n    <p>会在此博客放一些自己写的代码</p>\n    <p>和一些自己胡言乱语</p>\n</div>\n<div class=\"about\">\n    <p>喜欢的一首诗《过节》送给大家</p>\n    <p>作者：北岛</p>\n    <p>毒蛇炫耀口中的钉子</p>\n    <p>大地有著毒蛇</p>\n    <p>吞吃鸟蛋的寂静</p>\n    <p>所有钟表</p>\n    <p>停止在无梦的时刻</p>\n    <p>丰收聚敛着</p>\n    <p>田野死后的笑容</p>\n    <p>从水银的镜子出发</p>\n    <p>影像成双的人们</p>\n    <p>乘家庭的轮子</p>\n    <p>去集市</p>\n    <p>一位本地英雄</p>\n    <p>在废弃的停车场上</p>\n    <p>唱歌</p>\n    <p>玻璃晴朗</p>\n    <p>桔子辉煌</p>\n</div>\n\n"},{"title":"tags","date":"2021-05-11T02:59:32.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-05-11 10:59:32\n---\n","updated":"2021-05-11T02:59:32.196Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckojojkmi00021kwaazvvd7rw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"guestbook","date":"2021-05-11T03:13:01.000Z","_content":"<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2021-05-11 11:13:01\n---\n<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n","updated":"2021-05-11T03:13:43.809Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"ckojojkmk00041kwab50n1zpa","content":"<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n"}],"Post":[{"title":"锚点及void运算","date":"2019-07-08T07:52:05.000Z","excerpt":"锚点及void运算","position":null,"image_url":null,"_content":"\n```\n<a href=\"#\"></a>\n<a href=\"#none\"></a>\n<a href=\"###\"></a>\n<a href=\"javascript:\"></a>     //错误写法，没写分号\n<a href=\"javascript:;\"></a>\n<a href=\"javascript:void(0)\"></a>    //错误写法，没写分号\n<a href=\"javascript :void(0);\"></a>\n```\n\n- 第1种，点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。\n- 第2种，点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘。\n- 第3种，不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示，之前遇到过这种坑，之后再没用过。\n- 后面几种使用了javascript伪协议。\n- 第5和7种相等，不发生任何变化。void运算符只运算，不返回任何结果。\n- 为什么要列出4和6呢，有时候有些同学会忘记写分号，这样在IE6下面点击a标签，会造成页面中的gif暂停。\n","source":"_posts/anchor.md","raw":"---\ntitle: 锚点及void运算\ndate: 2019-07-08 15:52:05\nexcerpt: 锚点及void运算\ntags: \nposition:\nimage_url:\n---\n\n```\n<a href=\"#\"></a>\n<a href=\"#none\"></a>\n<a href=\"###\"></a>\n<a href=\"javascript:\"></a>     //错误写法，没写分号\n<a href=\"javascript:;\"></a>\n<a href=\"javascript:void(0)\"></a>    //错误写法，没写分号\n<a href=\"javascript :void(0);\"></a>\n```\n\n- 第1种，点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。\n- 第2种，点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘。\n- 第3种，不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示，之前遇到过这种坑，之后再没用过。\n- 后面几种使用了javascript伪协议。\n- 第5和7种相等，不发生任何变化。void运算符只运算，不返回任何结果。\n- 为什么要列出4和6呢，有时候有些同学会忘记写分号，这样在IE6下面点击a标签，会造成页面中的gif暂停。\n","slug":"anchor","published":1,"updated":"2021-05-10T07:54:50.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmf00011kwa9q2220gs","content":"<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;#none&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;###&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;    <span class=\"hljs-comment\"> //错误写法，没写分号</span><br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:;&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:void(0)&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;   <span class=\"hljs-comment\"> //错误写法，没写分号</span><br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript :void(0);&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第1种，点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。</li>\n<li>第2种，点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘。</li>\n<li>第3种，不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示，之前遇到过这种坑，之后再没用过。</li>\n<li>后面几种使用了javascript伪协议。</li>\n<li>第5和7种相等，不发生任何变化。void运算符只运算，不返回任何结果。</li>\n<li>为什么要列出4和6呢，有时候有些同学会忘记写分号，这样在IE6下面点击a标签，会造成页面中的gif暂停。</li>\n</ul>\n","site":{"data":{}},"more":"<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;#none&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;###&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;    <span class=\"hljs-comment\"> //错误写法，没写分号</span><br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:;&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript:void(0)&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;   <span class=\"hljs-comment\"> //错误写法，没写分号</span><br>&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;javascript :void(0);&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">a</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第1种，点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。</li>\n<li>第2种，点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘。</li>\n<li>第3种，不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示，之前遇到过这种坑，之后再没用过。</li>\n<li>后面几种使用了javascript伪协议。</li>\n<li>第5和7种相等，不发生任何变化。void运算符只运算，不返回任何结果。</li>\n<li>为什么要列出4和6呢，有时候有些同学会忘记写分号，这样在IE6下面点击a标签，会造成页面中的gif暂停。</li>\n</ul>\n"},{"title":"angular的ChangeDetectorRef","date":"2020-05-10T08:58:07.000Z","excerpt":"angular的ChangeDetectorRef","position":null,"image_url":null,"_content":"\n### Angular有两种变化检测策略(Change Detection Strategy)\n```\nenum ChangeDetectionStrategy {\n  // 使用 CheckOnce 策略，这意味着自动更改检测将停用，\n  // 直到通过将策略设置为\"Default\"（总是检查）重新激活。\n  OnPush: 0 \n\n  // 使用默认的 CheckAlway 策略，其中更改检测是自动的，直到显式停用\n  Default: 1\n}\n\n当使用 OnPush 策略的时候，只有在以下任一情况下，Angular才会检测此组件\n1.组件的任一@Input属性被父组件设为新值，如果@Input是引用类型，则需被设为新的实例才会触发变化检测。\n2.事件发生。无论此事件是否和业务有关，甚至是个空事件，都可。\n```\n\n##### 使用\n```\n1、引入ChangeDetectorRef模块\nimport { ChangeDetectorRef } from “angular”;\n2、声明\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\n3、引用\nconstructor(private cd:ChangeDetectorRef) {\n}\n4、检测\nthis.cd.detectChanges();实时检测页面及其子元素的变化\n```\n\n##### ChangeDetectorRef 是组件的变化检测器的引用\n**当使用 OnPush 策略的时候，若输入属性没有发生变化，组件的变化检测将会被跳过**\n```\nonpush策略：\n如果组件众多，组件中又包含组件，那每次这种不加区分的变化检测对页面的性能却有一定的消耗，而针对这种问题优化就有了onPush的变化检测策略。\n\nexport abstract class ChangeDetectorRef {\n  abstract markForCheck(): void //当组件使用OnPush变更检测策略时，把该组件显式标记为已更改，以便它再次进行检查。\n  abstract detach(): void //从变更检测树中分离开组件。 已分离的组件在重新附加上去之前不会被检查。 与 detectChanges() 结合使用，可以实现局部变更检测。\n  abstract reattach(): void //把以前分离开的组件重新附加到变更检测树上。 组件会被默认附加到这棵树上。\n  abstract detectChanges(): void //检查该组件及其子组件。与 detach 结合使用可以实现局部变更检测。\n  abstract checkNoChanges(): void //检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。\n}\n```\n\n- markForCheck() - 当输入已更改或视图中发生了事件时，组件通常会标记为脏的（需要重新渲染）。调用此方法会确保即使那些触发器没有被触发，也仍然检查该组件。在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法。\n- detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法。\n- reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测\n- detectChanges() - 从该组件到各个子组件执行一次变化检测 检查该视图及其子视图。与 <a href=\"https://angular.cn/api/core/ChangeDetectorRef#detach\">detach</a> 结合使用可以实现局部变更检测。\n\n>脏数据：就是用户改变了数据，就为脏数据。\n>在submit时，一定要标记所有的control为脏数据，且更新值和有效性校验。原因是，初始化进入可能不改动数据直接保存，这时会不满足校验规则，但不会触发校验。\n","source":"_posts/ChangeDetectorRef.md","raw":"---\ntitle: angular的ChangeDetectorRef\ndate: 2020-05-10 16:58:07\nexcerpt: angular的ChangeDetectorRef\ntags:\nposition:\nimage_url:\n---\n\n### Angular有两种变化检测策略(Change Detection Strategy)\n```\nenum ChangeDetectionStrategy {\n  // 使用 CheckOnce 策略，这意味着自动更改检测将停用，\n  // 直到通过将策略设置为\"Default\"（总是检查）重新激活。\n  OnPush: 0 \n\n  // 使用默认的 CheckAlway 策略，其中更改检测是自动的，直到显式停用\n  Default: 1\n}\n\n当使用 OnPush 策略的时候，只有在以下任一情况下，Angular才会检测此组件\n1.组件的任一@Input属性被父组件设为新值，如果@Input是引用类型，则需被设为新的实例才会触发变化检测。\n2.事件发生。无论此事件是否和业务有关，甚至是个空事件，都可。\n```\n\n##### 使用\n```\n1、引入ChangeDetectorRef模块\nimport { ChangeDetectorRef } from “angular”;\n2、声明\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\n3、引用\nconstructor(private cd:ChangeDetectorRef) {\n}\n4、检测\nthis.cd.detectChanges();实时检测页面及其子元素的变化\n```\n\n##### ChangeDetectorRef 是组件的变化检测器的引用\n**当使用 OnPush 策略的时候，若输入属性没有发生变化，组件的变化检测将会被跳过**\n```\nonpush策略：\n如果组件众多，组件中又包含组件，那每次这种不加区分的变化检测对页面的性能却有一定的消耗，而针对这种问题优化就有了onPush的变化检测策略。\n\nexport abstract class ChangeDetectorRef {\n  abstract markForCheck(): void //当组件使用OnPush变更检测策略时，把该组件显式标记为已更改，以便它再次进行检查。\n  abstract detach(): void //从变更检测树中分离开组件。 已分离的组件在重新附加上去之前不会被检查。 与 detectChanges() 结合使用，可以实现局部变更检测。\n  abstract reattach(): void //把以前分离开的组件重新附加到变更检测树上。 组件会被默认附加到这棵树上。\n  abstract detectChanges(): void //检查该组件及其子组件。与 detach 结合使用可以实现局部变更检测。\n  abstract checkNoChanges(): void //检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。\n}\n```\n\n- markForCheck() - 当输入已更改或视图中发生了事件时，组件通常会标记为脏的（需要重新渲染）。调用此方法会确保即使那些触发器没有被触发，也仍然检查该组件。在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法。\n- detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法。\n- reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测\n- detectChanges() - 从该组件到各个子组件执行一次变化检测 检查该视图及其子视图。与 <a href=\"https://angular.cn/api/core/ChangeDetectorRef#detach\">detach</a> 结合使用可以实现局部变更检测。\n\n>脏数据：就是用户改变了数据，就为脏数据。\n>在submit时，一定要标记所有的control为脏数据，且更新值和有效性校验。原因是，初始化进入可能不改动数据直接保存，这时会不满足校验规则，但不会触发校验。\n","slug":"ChangeDetectorRef","published":1,"updated":"2021-05-10T09:06:10.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmj00031kwaa6626vfw","content":"<h3 id=\"Angular有两种变化检测策略-Change-Detection-Strategy\"><a href=\"#Angular有两种变化检测策略-Change-Detection-Strategy\" class=\"headerlink\" title=\"Angular有两种变化检测策略(Change Detection Strategy)\"></a>Angular有两种变化检测策略(Change Detection Strategy)</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">enum ChangeDetectionStrategy &#123;<br>  <span class=\"hljs-regexp\">//</span> 使用 CheckOnce 策略，这意味着自动更改检测将停用，<br>  <span class=\"hljs-regexp\">//</span> 直到通过将策略设置为<span class=\"hljs-string\">&quot;Default&quot;</span>（总是检查）重新激活。<br>  OnPush: <span class=\"hljs-number\">0</span> <br><br>  <span class=\"hljs-regexp\">//</span> 使用默认的 CheckAlway 策略，其中更改检测是自动的，直到显式停用<br>  Default: <span class=\"hljs-number\">1</span><br>&#125;<br><br>当使用 OnPush 策略的时候，只有在以下任一情况下，Angular才会检测此组件<br><span class=\"hljs-number\">1</span>.组件的任一@Input属性被父组件设为新值，如果@Input是引用类型，则需被设为新的实例才会触发变化检测。<br><span class=\"hljs-number\">2</span>.事件发生。无论此事件是否和业务有关，甚至是个空事件，都可。<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-number\">1</span>、引入ChangeDetectorRef模块<br>import <span class=\"hljs-comment\">&#123; ChangeDetectorRef &#125;</span> <span class=\"hljs-keyword\">from</span> “angular”;<br><span class=\"hljs-number\">2</span>、声明<br>@Component(<span class=\"hljs-comment\">&#123;</span><br><span class=\"hljs-comment\">  changeDetection: ChangeDetectionStrategy.OnPush,</span><br><span class=\"hljs-comment\">&#125;</span>)<br><span class=\"hljs-number\">3</span>、引用<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">private</span> cd:ChangeDetectorRef)</span> <span class=\"hljs-comment\">&#123;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-function\">&#125;</span></span><br><span class=\"hljs-function\">4、检测</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">this</span>.<span class=\"hljs-title\">cd</span>.<span class=\"hljs-title\">detectChanges</span><span class=\"hljs-params\">()</span>;</span>实时检测页面及其子元素的变化<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"ChangeDetectorRef-是组件的变化检测器的引用\"><a href=\"#ChangeDetectorRef-是组件的变化检测器的引用\" class=\"headerlink\" title=\"ChangeDetectorRef 是组件的变化检测器的引用\"></a>ChangeDetectorRef 是组件的变化检测器的引用</h5><p><strong>当使用 OnPush 策略的时候，若输入属性没有发生变化，组件的变化检测将会被跳过</strong></p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs d\">onpush策略：<br>如果组件众多，组件中又包含组件，那每次这种不加区分的变化检测对页面的性能却有一定的消耗，而针对这种问题优化就有了onPush的变化检测策略。<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> ChangeDetectorRef &#123;<br>  <span class=\"hljs-keyword\">abstract</span> markForCheck(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//当组件使用OnPush变更检测策略时，把该组件显式标记为已更改，以便它再次进行检查。</span><br>  <span class=\"hljs-keyword\">abstract</span> detach(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//从变更检测树中分离开组件。 已分离的组件在重新附加上去之前不会被检查。 与 detectChanges() 结合使用，可以实现局部变更检测。</span><br>  <span class=\"hljs-keyword\">abstract</span> reattach(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//把以前分离开的组件重新附加到变更检测树上。 组件会被默认附加到这棵树上。</span><br>  <span class=\"hljs-keyword\">abstract</span> detectChanges(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//检查该组件及其子组件。与 detach 结合使用可以实现局部变更检测。</span><br>  <span class=\"hljs-keyword\">abstract</span> checkNoChanges(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>markForCheck() - 当输入已更改或视图中发生了事件时，组件通常会标记为脏的（需要重新渲染）。调用此方法会确保即使那些触发器没有被触发，也仍然检查该组件。在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法。</li>\n<li>detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法。</li>\n<li>reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测</li>\n<li>detectChanges() - 从该组件到各个子组件执行一次变化检测 检查该视图及其子视图。与 <a href=\"https://angular.cn/api/core/ChangeDetectorRef#detach\">detach</a> 结合使用可以实现局部变更检测。</li>\n</ul>\n<blockquote>\n<p>脏数据：就是用户改变了数据，就为脏数据。<br>在submit时，一定要标记所有的control为脏数据，且更新值和有效性校验。原因是，初始化进入可能不改动数据直接保存，这时会不满足校验规则，但不会触发校验。</p>\n</blockquote>\n","site":{"data":{}},"more":"<h3 id=\"Angular有两种变化检测策略-Change-Detection-Strategy\"><a href=\"#Angular有两种变化检测策略-Change-Detection-Strategy\" class=\"headerlink\" title=\"Angular有两种变化检测策略(Change Detection Strategy)\"></a>Angular有两种变化检测策略(Change Detection Strategy)</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">enum ChangeDetectionStrategy &#123;<br>  <span class=\"hljs-regexp\">//</span> 使用 CheckOnce 策略，这意味着自动更改检测将停用，<br>  <span class=\"hljs-regexp\">//</span> 直到通过将策略设置为<span class=\"hljs-string\">&quot;Default&quot;</span>（总是检查）重新激活。<br>  OnPush: <span class=\"hljs-number\">0</span> <br><br>  <span class=\"hljs-regexp\">//</span> 使用默认的 CheckAlway 策略，其中更改检测是自动的，直到显式停用<br>  Default: <span class=\"hljs-number\">1</span><br>&#125;<br><br>当使用 OnPush 策略的时候，只有在以下任一情况下，Angular才会检测此组件<br><span class=\"hljs-number\">1</span>.组件的任一@Input属性被父组件设为新值，如果@Input是引用类型，则需被设为新的实例才会触发变化检测。<br><span class=\"hljs-number\">2</span>.事件发生。无论此事件是否和业务有关，甚至是个空事件，都可。<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-number\">1</span>、引入ChangeDetectorRef模块<br>import <span class=\"hljs-comment\">&#123; ChangeDetectorRef &#125;</span> <span class=\"hljs-keyword\">from</span> “angular”;<br><span class=\"hljs-number\">2</span>、声明<br>@Component(<span class=\"hljs-comment\">&#123;</span><br><span class=\"hljs-comment\">  changeDetection: ChangeDetectionStrategy.OnPush,</span><br><span class=\"hljs-comment\">&#125;</span>)<br><span class=\"hljs-number\">3</span>、引用<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">private</span> cd:ChangeDetectorRef)</span> <span class=\"hljs-comment\">&#123;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-function\">&#125;</span></span><br><span class=\"hljs-function\">4、检测</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">this</span>.<span class=\"hljs-title\">cd</span>.<span class=\"hljs-title\">detectChanges</span><span class=\"hljs-params\">()</span>;</span>实时检测页面及其子元素的变化<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"ChangeDetectorRef-是组件的变化检测器的引用\"><a href=\"#ChangeDetectorRef-是组件的变化检测器的引用\" class=\"headerlink\" title=\"ChangeDetectorRef 是组件的变化检测器的引用\"></a>ChangeDetectorRef 是组件的变化检测器的引用</h5><p><strong>当使用 OnPush 策略的时候，若输入属性没有发生变化，组件的变化检测将会被跳过</strong></p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs d\">onpush策略：<br>如果组件众多，组件中又包含组件，那每次这种不加区分的变化检测对页面的性能却有一定的消耗，而针对这种问题优化就有了onPush的变化检测策略。<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> ChangeDetectorRef &#123;<br>  <span class=\"hljs-keyword\">abstract</span> markForCheck(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//当组件使用OnPush变更检测策略时，把该组件显式标记为已更改，以便它再次进行检查。</span><br>  <span class=\"hljs-keyword\">abstract</span> detach(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//从变更检测树中分离开组件。 已分离的组件在重新附加上去之前不会被检查。 与 detectChanges() 结合使用，可以实现局部变更检测。</span><br>  <span class=\"hljs-keyword\">abstract</span> reattach(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//把以前分离开的组件重新附加到变更检测树上。 组件会被默认附加到这棵树上。</span><br>  <span class=\"hljs-keyword\">abstract</span> detectChanges(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//检查该组件及其子组件。与 detach 结合使用可以实现局部变更检测。</span><br>  <span class=\"hljs-keyword\">abstract</span> checkNoChanges(): <span class=\"hljs-keyword\">void</span> <span class=\"hljs-comment\">//检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>markForCheck() - 当输入已更改或视图中发生了事件时，组件通常会标记为脏的（需要重新渲染）。调用此方法会确保即使那些触发器没有被触发，也仍然检查该组件。在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法。</li>\n<li>detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法。</li>\n<li>reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测</li>\n<li>detectChanges() - 从该组件到各个子组件执行一次变化检测 检查该视图及其子视图。与 <a href=\"https://angular.cn/api/core/ChangeDetectorRef#detach\">detach</a> 结合使用可以实现局部变更检测。</li>\n</ul>\n<blockquote>\n<p>脏数据：就是用户改变了数据，就为脏数据。<br>在submit时，一定要标记所有的control为脏数据，且更新值和有效性校验。原因是，初始化进入可能不改动数据直接保存，这时会不满足校验规则，但不会触发校验。</p>\n</blockquote>\n"},{"title":"angular自定义表单组件","date":"2020-07-02T09:25:41.000Z","excerpt":"angular自定义表单组件","position":null,"image_url":null,"_content":"## 自定义表单组件可以分为两种：\n1、组件中有input、areatext、select等原生可设置formctrol组件。以下简称：【有原生组件】\n2、组件中没有以上组件。以下简称：【无原生组件】\n\n\n针对于以上两种类型组件，有相应两种方式形成组件。\n## 【有原生组件】\n>注意：父组件中使用子组件   需要加ngDefaultControl属性，否则会报错：no value accessor for form control with name\n\n```\n# 父组件\n<hc-form-mobile \n    ngDefaultControl \n    [parentForm]=\"form\" nz-col \n    [nzSm]=\"styleInfo.controlGridNum\" \n    formControlName=\"phone\" \n    [styleInfo]=\"styleInfo\"></hc-form-mobile>\n```\n\n```\n# 子组件  对应html中form属性也要设置未parentForm \nexport class FormMobileComponent implements OnInit {\n\n  @Input() parentForm :FormGroup;//从父组件传来的父组件formgroup\n  @Input() styleInfo :FormLayoutStyleInterface;\n\n  constructor(\n    public i18n: I18NService,\n  ) {}\n\n  ngOnInit(): void {//设置检验规则\n    this.phone.setValidators([Validators.required, Validators.pattern(/^1\\d{10}$/)]);\n  }\n\n  get phone() {\n    return this.parentForm.controls.phone;\n  }\n\n  set phone(data) {\n    this.parentForm.controls.phone.setValue(data);\n  }\n\n}\n```\n## 【无原生组件】\n```\n# 子组件  注意看【重点】\n@Component({\n  selector: 'hc-form-department',\n  templateUrl: './form-department.component.html',\n  styles: [\n  ],\n  //【重点1】\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: FormDepartmentComponent,\n    multi: true\n  }]\n})\n//【重点2】，实现接口ControlValueAccessor \nexport class FormDepartmentComponent implements OnInit,ControlValueAccessor {\n\n  form: FormGroup;\n  formChangeFn;\n\n  departmentList:[{\n    deptNum:'',\n    deptName:''\n  }];\n\n  nodes = [];\n\n  constructor(\n    public i18n: I18NService,\n    private fb: FormBuilder,\n    private http: HttpClientService,\n    private convertTree: ConvertTreeService,\n    private modal: ModalHelper\n  ) {\n    this.form = fb.group({\n      deptNum: [null],\n    });\n  }\n\n  ngOnInit(): void {\n    this.getAllDepartment();\n  }\n\n  /**\n   * 新建部门\n   */\n  addDepartment(){\n    this.modal.createStatic(UserDepartmentEditComponent,\n      {record: {isEdit: false, key: 0}},\n      { size: 'md'}\n    ).subscribe((res) => {\n      this.getAllDepartment();\n    });\n  }\n\n  /**\n   * 获取全部部门列表\n   */\n  getAllDepartment(){}\n\n  onChange(data){\n    this.formChangeFn(data);\n  }\n  //【重点3】实现方法registerOnChange、registerOnTouched、writeValue\n  registerOnChange(fn: any): void {\n    this.formChangeFn = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  writeValue(value: any): void {\n    if(value){\n      this.deptNum = value;\n    }\n  }\n\n  get deptNum() {\n    return this.form.controls.deptNum;\n  }\n\n  set deptNum(data) {\n    this.form.controls.deptNum.setValue(data);\n  }\n  //【重点4】这是自定义的函数，为了在父组件提交时检测子组件的值并提示。\n  checkValidity() {\n    this.deptNum.markAsDirty();\n    this.deptNum.updateValueAndValidity();\n  }\n\n}\n```\n","source":"_posts/angular-custom-form.md","raw":"---\ntitle: angular自定义表单组件\ndate: 2020-07-02 17:25:41\nexcerpt: angular自定义表单组件\ntags:\nposition:\nimage_url:\n---\n## 自定义表单组件可以分为两种：\n1、组件中有input、areatext、select等原生可设置formctrol组件。以下简称：【有原生组件】\n2、组件中没有以上组件。以下简称：【无原生组件】\n\n\n针对于以上两种类型组件，有相应两种方式形成组件。\n## 【有原生组件】\n>注意：父组件中使用子组件   需要加ngDefaultControl属性，否则会报错：no value accessor for form control with name\n\n```\n# 父组件\n<hc-form-mobile \n    ngDefaultControl \n    [parentForm]=\"form\" nz-col \n    [nzSm]=\"styleInfo.controlGridNum\" \n    formControlName=\"phone\" \n    [styleInfo]=\"styleInfo\"></hc-form-mobile>\n```\n\n```\n# 子组件  对应html中form属性也要设置未parentForm \nexport class FormMobileComponent implements OnInit {\n\n  @Input() parentForm :FormGroup;//从父组件传来的父组件formgroup\n  @Input() styleInfo :FormLayoutStyleInterface;\n\n  constructor(\n    public i18n: I18NService,\n  ) {}\n\n  ngOnInit(): void {//设置检验规则\n    this.phone.setValidators([Validators.required, Validators.pattern(/^1\\d{10}$/)]);\n  }\n\n  get phone() {\n    return this.parentForm.controls.phone;\n  }\n\n  set phone(data) {\n    this.parentForm.controls.phone.setValue(data);\n  }\n\n}\n```\n## 【无原生组件】\n```\n# 子组件  注意看【重点】\n@Component({\n  selector: 'hc-form-department',\n  templateUrl: './form-department.component.html',\n  styles: [\n  ],\n  //【重点1】\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: FormDepartmentComponent,\n    multi: true\n  }]\n})\n//【重点2】，实现接口ControlValueAccessor \nexport class FormDepartmentComponent implements OnInit,ControlValueAccessor {\n\n  form: FormGroup;\n  formChangeFn;\n\n  departmentList:[{\n    deptNum:'',\n    deptName:''\n  }];\n\n  nodes = [];\n\n  constructor(\n    public i18n: I18NService,\n    private fb: FormBuilder,\n    private http: HttpClientService,\n    private convertTree: ConvertTreeService,\n    private modal: ModalHelper\n  ) {\n    this.form = fb.group({\n      deptNum: [null],\n    });\n  }\n\n  ngOnInit(): void {\n    this.getAllDepartment();\n  }\n\n  /**\n   * 新建部门\n   */\n  addDepartment(){\n    this.modal.createStatic(UserDepartmentEditComponent,\n      {record: {isEdit: false, key: 0}},\n      { size: 'md'}\n    ).subscribe((res) => {\n      this.getAllDepartment();\n    });\n  }\n\n  /**\n   * 获取全部部门列表\n   */\n  getAllDepartment(){}\n\n  onChange(data){\n    this.formChangeFn(data);\n  }\n  //【重点3】实现方法registerOnChange、registerOnTouched、writeValue\n  registerOnChange(fn: any): void {\n    this.formChangeFn = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  writeValue(value: any): void {\n    if(value){\n      this.deptNum = value;\n    }\n  }\n\n  get deptNum() {\n    return this.form.controls.deptNum;\n  }\n\n  set deptNum(data) {\n    this.form.controls.deptNum.setValue(data);\n  }\n  //【重点4】这是自定义的函数，为了在父组件提交时检测子组件的值并提示。\n  checkValidity() {\n    this.deptNum.markAsDirty();\n    this.deptNum.updateValueAndValidity();\n  }\n\n}\n```\n","slug":"angular-custom-form","published":1,"updated":"2021-05-10T09:29:08.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmk00051kwa7x4s4pwk","content":"<h2 id=\"自定义表单组件可以分为两种：\"><a href=\"#自定义表单组件可以分为两种：\" class=\"headerlink\" title=\"自定义表单组件可以分为两种：\"></a>自定义表单组件可以分为两种：</h2><p>1、组件中有input、areatext、select等原生可设置formctrol组件。以下简称：【有原生组件】<br>2、组件中没有以上组件。以下简称：【无原生组件】</p>\n<p>针对于以上两种类型组件，有相应两种方式形成组件。</p>\n<h2 id=\"【有原生组件】\"><a href=\"#【有原生组件】\" class=\"headerlink\" title=\"【有原生组件】\"></a>【有原生组件】</h2><blockquote>\n<p>注意：父组件中使用子组件   需要加ngDefaultControl属性，否则会报错：no value accessor for form control with name</p>\n</blockquote>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-meta\"># 父组件</span><br>&lt;hc-form-mobile <br>    ngDefaultControl <br>    [<span class=\"hljs-meta\">parentForm</span>]=<span class=\"hljs-string\">&quot;form&quot;</span> nz-col <br>    [<span class=\"hljs-meta\">nzSm</span>]=<span class=\"hljs-string\">&quot;styleInfo.controlGridNum&quot;</span> <br>    formControlName=<span class=\"hljs-string\">&quot;phone&quot;</span> <br>    [<span class=\"hljs-meta\">styleInfo</span>]=<span class=\"hljs-string\">&quot;styleInfo&quot;</span>&gt;&lt;/hc-form-mobile&gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"># 子组件  对应html中form属性也要设置未parentForm <br>export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormMobileComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>&#123;<br><br>  <span class=\"hljs-meta\">@Input()</span> parentForm :FormGroup;<span class=\"hljs-comment\">//从父组件传来的父组件formgroup</span><br>  <span class=\"hljs-meta\">@Input()</span> styleInfo :FormLayoutStyleInterface;<br><br>  <span class=\"hljs-keyword\">constructor</span>(<br>    <span class=\"hljs-keyword\">public</span> i18n: I18NService,<br>  ) &#123;&#125;<br><br>  ngOnInit(): void &#123;<span class=\"hljs-comment\">//设置检验规则</span><br>    <span class=\"hljs-keyword\">this</span>.phone.setValidators([Validators.required, Validators.pattern(/^<span class=\"hljs-number\">1</span>\\d&#123;<span class=\"hljs-number\">10</span>&#125;$/)]);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> phone() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.parentForm.controls.phone;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> phone(<span class=\"hljs-keyword\">data</span>) &#123;<br>    <span class=\"hljs-keyword\">this</span>.parentForm.controls.phone.setValue(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"【无原生组件】\"><a href=\"#【无原生组件】\" class=\"headerlink\" title=\"【无原生组件】\"></a>【无原生组件】</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"># 子组件  注意看【重点】<br><span class=\"hljs-meta\">@Component(&#123;</span><br><span class=\"hljs-meta\">  selector: <span class=\"hljs-meta-string\">&#x27;hc-form-department&#x27;</span>,</span><br><span class=\"hljs-meta\">  templateUrl: <span class=\"hljs-meta-string\">&#x27;./form-department.component.html&#x27;</span>,</span><br><span class=\"hljs-meta\">  styles: [</span><br><span class=\"hljs-meta\">  ],</span><br><span class=\"hljs-meta\">  //【重点1】</span><br><span class=\"hljs-meta\">  providers: [&#123;</span><br><span class=\"hljs-meta\">    provide: NG_VALUE_ACCESSOR,</span><br><span class=\"hljs-meta\">    useExisting: FormDepartmentComponent,</span><br><span class=\"hljs-meta\">    multi: true</span><br><span class=\"hljs-meta\">  &#125;]</span><br><span class=\"hljs-meta\">&#125;)</span><br><span class=\"hljs-comment\">//【重点2】，实现接口ControlValueAccessor </span><br>export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormDepartmentComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span>,<span class=\"hljs-type\">ControlValueAccessor &#123;</span></span><br><br>  form: FormGroup;<br>  formChangeFn;<br><br>  departmentList:[&#123;<br>    deptNum:<span class=\"hljs-string\">&#x27;&#x27;</span>,<br>    deptName:<span class=\"hljs-string\">&#x27;&#x27;</span><br>  &#125;];<br><br>  nodes = [];<br><br>  <span class=\"hljs-keyword\">constructor</span>(<br>    <span class=\"hljs-keyword\">public</span> i18n: I18NService,<br>    <span class=\"hljs-keyword\">private</span> fb: FormBuilder,<br>    <span class=\"hljs-keyword\">private</span> http: HttpClientService,<br>    <span class=\"hljs-keyword\">private</span> convertTree: ConvertTreeService,<br>    <span class=\"hljs-keyword\">private</span> modal: ModalHelper<br>  ) &#123;<br>    <span class=\"hljs-keyword\">this</span>.form = fb.group(&#123;<br>      deptNum: [<span class=\"hljs-literal\">null</span>],<br>    &#125;);<br>  &#125;<br><br>  ngOnInit(): void &#123;<br>    <span class=\"hljs-keyword\">this</span>.getAllDepartment();<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 新建部门</span><br><span class=\"hljs-comment\">   */</span><br>  addDepartment()&#123;<br>    <span class=\"hljs-keyword\">this</span>.modal.createStatic(UserDepartmentEditComponent,<br>      &#123;record: &#123;isEdit: <span class=\"hljs-literal\">false</span>, key: <span class=\"hljs-number\">0</span>&#125;&#125;,<br>      &#123; size: <span class=\"hljs-string\">&#x27;md&#x27;</span>&#125;<br>    ).subscribe((res) =&gt; &#123;<br>      <span class=\"hljs-keyword\">this</span>.getAllDepartment();<br>    &#125;);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 获取全部部门列表</span><br><span class=\"hljs-comment\">   */</span><br>  getAllDepartment()&#123;&#125;<br><br>  onChange(<span class=\"hljs-keyword\">data</span>)&#123;<br>    <span class=\"hljs-keyword\">this</span>.formChangeFn(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br>  <span class=\"hljs-comment\">//【重点3】实现方法registerOnChange、registerOnTouched、writeValue</span><br>  registerOnChange(fn: any): void &#123;<br>    <span class=\"hljs-keyword\">this</span>.formChangeFn = fn;<br>  &#125;<br><br>  registerOnTouched(fn: any): void &#123;<br>  &#125;<br><br>  writeValue(value: any): void &#123;<br>    <span class=\"hljs-keyword\">if</span>(value)&#123;<br>      <span class=\"hljs-keyword\">this</span>.deptNum = value;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> deptNum() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.form.controls.deptNum;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> deptNum(<span class=\"hljs-keyword\">data</span>) &#123;<br>    <span class=\"hljs-keyword\">this</span>.form.controls.deptNum.setValue(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br>  <span class=\"hljs-comment\">//【重点4】这是自定义的函数，为了在父组件提交时检测子组件的值并提示。</span><br>  checkValidity() &#123;<br>    <span class=\"hljs-keyword\">this</span>.deptNum.markAsDirty();<br>    <span class=\"hljs-keyword\">this</span>.deptNum.updateValueAndValidity();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<h2 id=\"自定义表单组件可以分为两种：\"><a href=\"#自定义表单组件可以分为两种：\" class=\"headerlink\" title=\"自定义表单组件可以分为两种：\"></a>自定义表单组件可以分为两种：</h2><p>1、组件中有input、areatext、select等原生可设置formctrol组件。以下简称：【有原生组件】<br>2、组件中没有以上组件。以下简称：【无原生组件】</p>\n<p>针对于以上两种类型组件，有相应两种方式形成组件。</p>\n<h2 id=\"【有原生组件】\"><a href=\"#【有原生组件】\" class=\"headerlink\" title=\"【有原生组件】\"></a>【有原生组件】</h2><blockquote>\n<p>注意：父组件中使用子组件   需要加ngDefaultControl属性，否则会报错：no value accessor for form control with name</p>\n</blockquote>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-meta\"># 父组件</span><br>&lt;hc-form-mobile <br>    ngDefaultControl <br>    [<span class=\"hljs-meta\">parentForm</span>]=<span class=\"hljs-string\">&quot;form&quot;</span> nz-col <br>    [<span class=\"hljs-meta\">nzSm</span>]=<span class=\"hljs-string\">&quot;styleInfo.controlGridNum&quot;</span> <br>    formControlName=<span class=\"hljs-string\">&quot;phone&quot;</span> <br>    [<span class=\"hljs-meta\">styleInfo</span>]=<span class=\"hljs-string\">&quot;styleInfo&quot;</span>&gt;&lt;/hc-form-mobile&gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"># 子组件  对应html中form属性也要设置未parentForm <br>export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormMobileComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>&#123;<br><br>  <span class=\"hljs-meta\">@Input()</span> parentForm :FormGroup;<span class=\"hljs-comment\">//从父组件传来的父组件formgroup</span><br>  <span class=\"hljs-meta\">@Input()</span> styleInfo :FormLayoutStyleInterface;<br><br>  <span class=\"hljs-keyword\">constructor</span>(<br>    <span class=\"hljs-keyword\">public</span> i18n: I18NService,<br>  ) &#123;&#125;<br><br>  ngOnInit(): void &#123;<span class=\"hljs-comment\">//设置检验规则</span><br>    <span class=\"hljs-keyword\">this</span>.phone.setValidators([Validators.required, Validators.pattern(/^<span class=\"hljs-number\">1</span>\\d&#123;<span class=\"hljs-number\">10</span>&#125;$/)]);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> phone() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.parentForm.controls.phone;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> phone(<span class=\"hljs-keyword\">data</span>) &#123;<br>    <span class=\"hljs-keyword\">this</span>.parentForm.controls.phone.setValue(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"【无原生组件】\"><a href=\"#【无原生组件】\" class=\"headerlink\" title=\"【无原生组件】\"></a>【无原生组件】</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"># 子组件  注意看【重点】<br><span class=\"hljs-meta\">@Component(&#123;</span><br><span class=\"hljs-meta\">  selector: <span class=\"hljs-meta-string\">&#x27;hc-form-department&#x27;</span>,</span><br><span class=\"hljs-meta\">  templateUrl: <span class=\"hljs-meta-string\">&#x27;./form-department.component.html&#x27;</span>,</span><br><span class=\"hljs-meta\">  styles: [</span><br><span class=\"hljs-meta\">  ],</span><br><span class=\"hljs-meta\">  //【重点1】</span><br><span class=\"hljs-meta\">  providers: [&#123;</span><br><span class=\"hljs-meta\">    provide: NG_VALUE_ACCESSOR,</span><br><span class=\"hljs-meta\">    useExisting: FormDepartmentComponent,</span><br><span class=\"hljs-meta\">    multi: true</span><br><span class=\"hljs-meta\">  &#125;]</span><br><span class=\"hljs-meta\">&#125;)</span><br><span class=\"hljs-comment\">//【重点2】，实现接口ControlValueAccessor </span><br>export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormDepartmentComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span>,<span class=\"hljs-type\">ControlValueAccessor &#123;</span></span><br><br>  form: FormGroup;<br>  formChangeFn;<br><br>  departmentList:[&#123;<br>    deptNum:<span class=\"hljs-string\">&#x27;&#x27;</span>,<br>    deptName:<span class=\"hljs-string\">&#x27;&#x27;</span><br>  &#125;];<br><br>  nodes = [];<br><br>  <span class=\"hljs-keyword\">constructor</span>(<br>    <span class=\"hljs-keyword\">public</span> i18n: I18NService,<br>    <span class=\"hljs-keyword\">private</span> fb: FormBuilder,<br>    <span class=\"hljs-keyword\">private</span> http: HttpClientService,<br>    <span class=\"hljs-keyword\">private</span> convertTree: ConvertTreeService,<br>    <span class=\"hljs-keyword\">private</span> modal: ModalHelper<br>  ) &#123;<br>    <span class=\"hljs-keyword\">this</span>.form = fb.group(&#123;<br>      deptNum: [<span class=\"hljs-literal\">null</span>],<br>    &#125;);<br>  &#125;<br><br>  ngOnInit(): void &#123;<br>    <span class=\"hljs-keyword\">this</span>.getAllDepartment();<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 新建部门</span><br><span class=\"hljs-comment\">   */</span><br>  addDepartment()&#123;<br>    <span class=\"hljs-keyword\">this</span>.modal.createStatic(UserDepartmentEditComponent,<br>      &#123;record: &#123;isEdit: <span class=\"hljs-literal\">false</span>, key: <span class=\"hljs-number\">0</span>&#125;&#125;,<br>      &#123; size: <span class=\"hljs-string\">&#x27;md&#x27;</span>&#125;<br>    ).subscribe((res) =&gt; &#123;<br>      <span class=\"hljs-keyword\">this</span>.getAllDepartment();<br>    &#125;);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 获取全部部门列表</span><br><span class=\"hljs-comment\">   */</span><br>  getAllDepartment()&#123;&#125;<br><br>  onChange(<span class=\"hljs-keyword\">data</span>)&#123;<br>    <span class=\"hljs-keyword\">this</span>.formChangeFn(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br>  <span class=\"hljs-comment\">//【重点3】实现方法registerOnChange、registerOnTouched、writeValue</span><br>  registerOnChange(fn: any): void &#123;<br>    <span class=\"hljs-keyword\">this</span>.formChangeFn = fn;<br>  &#125;<br><br>  registerOnTouched(fn: any): void &#123;<br>  &#125;<br><br>  writeValue(value: any): void &#123;<br>    <span class=\"hljs-keyword\">if</span>(value)&#123;<br>      <span class=\"hljs-keyword\">this</span>.deptNum = value;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> deptNum() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.form.controls.deptNum;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> deptNum(<span class=\"hljs-keyword\">data</span>) &#123;<br>    <span class=\"hljs-keyword\">this</span>.form.controls.deptNum.setValue(<span class=\"hljs-keyword\">data</span>);<br>  &#125;<br>  <span class=\"hljs-comment\">//【重点4】这是自定义的函数，为了在父组件提交时检测子组件的值并提示。</span><br>  checkValidity() &#123;<br>    <span class=\"hljs-keyword\">this</span>.deptNum.markAsDirty();<br>    <span class=\"hljs-keyword\">this</span>.deptNum.updateValueAndValidity();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"angular服务详解","date":"2020-08-04T09:09:56.000Z","excerpt":"angular服务详解","position":null,"image_url":null,"_content":"### 根据具体使用场景， providers: [] 将有三种不同的用法：\n1. 在预加载的模块的@NgModule装饰器中指定 providers: []\n2. 在懒加载的模块的@NgModule装饰器中指定 providers: [] \n3. 在@Component和@Directive装饰器中指定 providers: []\n\n\n\n`angular6`之后，我们通过使用 `@Injectable` 装饰器的新增的 `provideIn` 属性来使用它。\n我们可以将`provideIn`视为以反向方式指定依赖关系。 现在不是模块申明需要哪些服务，而是服务本身宣布它应该提供给哪些模块使用\n在 `providedIn` 出现之前，需要在主模块的 `providers: []` 中注入所有公共服务。然后，组件需要导入该模块，这将导致所有（可能的大量）的服务导入进该组件，即使我们只想使用其中一个服务。\n\n------------------\n###### 服务注入过程图解：\n![imgage](/images/angular/service.png)\n","source":"_posts/angular-service.md","raw":"---\ntitle: angular服务详解\ndate: 2020-08-04 17:09:56\nexcerpt: angular服务详解\ntags:\nposition:\nimage_url:\n---\n### 根据具体使用场景， providers: [] 将有三种不同的用法：\n1. 在预加载的模块的@NgModule装饰器中指定 providers: []\n2. 在懒加载的模块的@NgModule装饰器中指定 providers: [] \n3. 在@Component和@Directive装饰器中指定 providers: []\n\n\n\n`angular6`之后，我们通过使用 `@Injectable` 装饰器的新增的 `provideIn` 属性来使用它。\n我们可以将`provideIn`视为以反向方式指定依赖关系。 现在不是模块申明需要哪些服务，而是服务本身宣布它应该提供给哪些模块使用\n在 `providedIn` 出现之前，需要在主模块的 `providers: []` 中注入所有公共服务。然后，组件需要导入该模块，这将导致所有（可能的大量）的服务导入进该组件，即使我们只想使用其中一个服务。\n\n------------------\n###### 服务注入过程图解：\n![imgage](/images/angular/service.png)\n","slug":"angular-service","published":1,"updated":"2021-05-10T09:16:04.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkml00061kwadm2n1j2n","content":"<h3 id=\"根据具体使用场景，-providers-将有三种不同的用法：\"><a href=\"#根据具体使用场景，-providers-将有三种不同的用法：\" class=\"headerlink\" title=\"根据具体使用场景， providers: [] 将有三种不同的用法：\"></a>根据具体使用场景， providers: [] 将有三种不同的用法：</h3><ol>\n<li>在预加载的模块的@NgModule装饰器中指定 providers: []</li>\n<li>在懒加载的模块的@NgModule装饰器中指定 providers: [] </li>\n<li>在@Component和@Directive装饰器中指定 providers: []</li>\n</ol>\n<p><code>angular6</code>之后，我们通过使用 <code>@Injectable</code> 装饰器的新增的 <code>provideIn</code> 属性来使用它。<br>我们可以将<code>provideIn</code>视为以反向方式指定依赖关系。 现在不是模块申明需要哪些服务，而是服务本身宣布它应该提供给哪些模块使用<br>在 <code>providedIn</code> 出现之前，需要在主模块的 <code>providers: []</code> 中注入所有公共服务。然后，组件需要导入该模块，这将导致所有（可能的大量）的服务导入进该组件，即使我们只想使用其中一个服务。</p>\n<hr>\n<h6 id=\"服务注入过程图解：\"><a href=\"#服务注入过程图解：\" class=\"headerlink\" title=\"服务注入过程图解：\"></a>服务注入过程图解：</h6><p><img src=\"/images/angular/service.png\" alt=\"imgage\"></p>\n","site":{"data":{}},"more":"<h3 id=\"根据具体使用场景，-providers-将有三种不同的用法：\"><a href=\"#根据具体使用场景，-providers-将有三种不同的用法：\" class=\"headerlink\" title=\"根据具体使用场景， providers: [] 将有三种不同的用法：\"></a>根据具体使用场景， providers: [] 将有三种不同的用法：</h3><ol>\n<li>在预加载的模块的@NgModule装饰器中指定 providers: []</li>\n<li>在懒加载的模块的@NgModule装饰器中指定 providers: [] </li>\n<li>在@Component和@Directive装饰器中指定 providers: []</li>\n</ol>\n<p><code>angular6</code>之后，我们通过使用 <code>@Injectable</code> 装饰器的新增的 <code>provideIn</code> 属性来使用它。<br>我们可以将<code>provideIn</code>视为以反向方式指定依赖关系。 现在不是模块申明需要哪些服务，而是服务本身宣布它应该提供给哪些模块使用<br>在 <code>providedIn</code> 出现之前，需要在主模块的 <code>providers: []</code> 中注入所有公共服务。然后，组件需要导入该模块，这将导致所有（可能的大量）的服务导入进该组件，即使我们只想使用其中一个服务。</p>\n<hr>\n<h6 id=\"服务注入过程图解：\"><a href=\"#服务注入过程图解：\" class=\"headerlink\" title=\"服务注入过程图解：\"></a>服务注入过程图解：</h6><p><img src=\"/images/angular/service.png\" alt=\"imgage\"></p>\n"},{"title":"angular-依赖注入","date":"2020-02-04T09:17:30.000Z","excerpt":"依赖注入","position":null,"image_url":null,"_content":">在JavaScript语境下，依赖注入就是函数参数是函数而已（高阶函数，因为JS没有类），而在TypeScript语境下，依赖注入就是在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化。\n\n依赖注入就是控制反转概念的一种实现模式。\n之前是我们需要什么服务，就去主动new一个对象，那依赖注入就是服务先注册到DI框架中，我去声明我需要什么服务，DI框架再把我需要的服务注入进来。如下图：\n\n![image](/images/angular/DI.png)\n\n##### 依赖注入作用\n&ensp; &ensp; 让框架帮你处理重要对象的生命周期的管理，不需要你显式地进行管理(对象构造和销毁)\n\n\n##### 依赖注入包含三部分：\n1. 提供商：负责把一个令牌（可能是字符串也可能是类）映射到一个依赖的列表，它告诉angular该如何根据指定的令牌创建对象。\n2. 注入器：解析依赖并注入他们。angular不需要我们创建注入器，在启动时，它会自己创建一个应用注入器—platformBrowserDynamic().bootstrapModule(AppModule)\n3. 依赖：被用于注入的对象，例如服务等等\n\n##### 详解\n1、提供商\n- 类提供商 useClass\n- 别名提供商 useExisting\n- 值提供商 useValue\n- 工厂提供商 useFactory\n\n2、令牌：\n- 类\n- 类-接口\n- InjectionToken\n\n3、注册提供商：可在模块中或组件中\n4、服务：在服务中@Injectable() 是必写的。**angular6之后，我们通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用它。**\n","source":"_posts/angular-di.md","raw":"---\ntitle: angular-依赖注入\ndate: 2020-02-04 17:17:30\nexcerpt: 依赖注入\ntags:\nposition:\nimage_url:\n---\n>在JavaScript语境下，依赖注入就是函数参数是函数而已（高阶函数，因为JS没有类），而在TypeScript语境下，依赖注入就是在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化。\n\n依赖注入就是控制反转概念的一种实现模式。\n之前是我们需要什么服务，就去主动new一个对象，那依赖注入就是服务先注册到DI框架中，我去声明我需要什么服务，DI框架再把我需要的服务注入进来。如下图：\n\n![image](/images/angular/DI.png)\n\n##### 依赖注入作用\n&ensp; &ensp; 让框架帮你处理重要对象的生命周期的管理，不需要你显式地进行管理(对象构造和销毁)\n\n\n##### 依赖注入包含三部分：\n1. 提供商：负责把一个令牌（可能是字符串也可能是类）映射到一个依赖的列表，它告诉angular该如何根据指定的令牌创建对象。\n2. 注入器：解析依赖并注入他们。angular不需要我们创建注入器，在启动时，它会自己创建一个应用注入器—platformBrowserDynamic().bootstrapModule(AppModule)\n3. 依赖：被用于注入的对象，例如服务等等\n\n##### 详解\n1、提供商\n- 类提供商 useClass\n- 别名提供商 useExisting\n- 值提供商 useValue\n- 工厂提供商 useFactory\n\n2、令牌：\n- 类\n- 类-接口\n- InjectionToken\n\n3、注册提供商：可在模块中或组件中\n4、服务：在服务中@Injectable() 是必写的。**angular6之后，我们通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用它。**\n","slug":"angular-di","published":1,"updated":"2021-05-10T09:23:22.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmm00071kwa5czhbsii","content":"<blockquote>\n<p>在JavaScript语境下，依赖注入就是函数参数是函数而已（高阶函数，因为JS没有类），而在TypeScript语境下，依赖注入就是在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化。</p>\n</blockquote>\n<p>依赖注入就是控制反转概念的一种实现模式。<br>之前是我们需要什么服务，就去主动new一个对象，那依赖注入就是服务先注册到DI框架中，我去声明我需要什么服务，DI框架再把我需要的服务注入进来。如下图：</p>\n<p><img src=\"/images/angular/DI.png\" alt=\"image\"></p>\n<h5 id=\"依赖注入作用\"><a href=\"#依赖注入作用\" class=\"headerlink\" title=\"依赖注入作用\"></a>依赖注入作用</h5><p>&ensp; &ensp; 让框架帮你处理重要对象的生命周期的管理，不需要你显式地进行管理(对象构造和销毁)</p>\n<h5 id=\"依赖注入包含三部分：\"><a href=\"#依赖注入包含三部分：\" class=\"headerlink\" title=\"依赖注入包含三部分：\"></a>依赖注入包含三部分：</h5><ol>\n<li>提供商：负责把一个令牌（可能是字符串也可能是类）映射到一个依赖的列表，它告诉angular该如何根据指定的令牌创建对象。</li>\n<li>注入器：解析依赖并注入他们。angular不需要我们创建注入器，在启动时，它会自己创建一个应用注入器—platformBrowserDynamic().bootstrapModule(AppModule)</li>\n<li>依赖：被用于注入的对象，例如服务等等</li>\n</ol>\n<h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><p>1、提供商</p>\n<ul>\n<li>类提供商 useClass</li>\n<li>别名提供商 useExisting</li>\n<li>值提供商 useValue</li>\n<li>工厂提供商 useFactory</li>\n</ul>\n<p>2、令牌：</p>\n<ul>\n<li>类</li>\n<li>类-接口</li>\n<li>InjectionToken</li>\n</ul>\n<p>3、注册提供商：可在模块中或组件中<br>4、服务：在服务中@Injectable() 是必写的。<strong>angular6之后，我们通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用它。</strong></p>\n","site":{"data":{}},"more":"<blockquote>\n<p>在JavaScript语境下，依赖注入就是函数参数是函数而已（高阶函数，因为JS没有类），而在TypeScript语境下，依赖注入就是在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化。</p>\n</blockquote>\n<p>依赖注入就是控制反转概念的一种实现模式。<br>之前是我们需要什么服务，就去主动new一个对象，那依赖注入就是服务先注册到DI框架中，我去声明我需要什么服务，DI框架再把我需要的服务注入进来。如下图：</p>\n<p><img src=\"/images/angular/DI.png\" alt=\"image\"></p>\n<h5 id=\"依赖注入作用\"><a href=\"#依赖注入作用\" class=\"headerlink\" title=\"依赖注入作用\"></a>依赖注入作用</h5><p>&ensp; &ensp; 让框架帮你处理重要对象的生命周期的管理，不需要你显式地进行管理(对象构造和销毁)</p>\n<h5 id=\"依赖注入包含三部分：\"><a href=\"#依赖注入包含三部分：\" class=\"headerlink\" title=\"依赖注入包含三部分：\"></a>依赖注入包含三部分：</h5><ol>\n<li>提供商：负责把一个令牌（可能是字符串也可能是类）映射到一个依赖的列表，它告诉angular该如何根据指定的令牌创建对象。</li>\n<li>注入器：解析依赖并注入他们。angular不需要我们创建注入器，在启动时，它会自己创建一个应用注入器—platformBrowserDynamic().bootstrapModule(AppModule)</li>\n<li>依赖：被用于注入的对象，例如服务等等</li>\n</ol>\n<h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><p>1、提供商</p>\n<ul>\n<li>类提供商 useClass</li>\n<li>别名提供商 useExisting</li>\n<li>值提供商 useValue</li>\n<li>工厂提供商 useFactory</li>\n</ul>\n<p>2、令牌：</p>\n<ul>\n<li>类</li>\n<li>类-接口</li>\n<li>InjectionToken</li>\n</ul>\n<p>3、注册提供商：可在模块中或组件中<br>4、服务：在服务中@Injectable() 是必写的。<strong>angular6之后，我们通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用它。</strong></p>\n"},{"title":"angular国际化方案","date":"2020-05-09T09:30:05.000Z","excerpt":"angular","position":null,"image_url":null,"_content":"\nAngular 国际化常见有 Angular 内置和基于 @ngx-translate/core （请参考官网了解更多实现细节）两种不同国际化方案。\n\n### 两种方案\n###### 1、Angular 内置（多个app）\nAngular 文档（中文版）有完整的描述，注意需要为每一种语言构建和部署单独的应用程序版本。\n\n###### 2、@ngx-translate/core（推荐，只用一套app）\n@ngx-translate/core 是社区版本的 Angular 国际化，相比较 Angular 内置它是动态性，无须针对不同语言构建和部署单独版本，并且大部分情况下可以立即呈现。\n\n---\n### @ngx-translate/core使用\n###### 1、html中\n```\n<a>{{ 'menu.fullscreen' | i18n}}</a>\n```\n\n###### 2、ts中,动态引入语言包，获取其中的文字\n```\nthis.i18n.fanyi('app.analysis.traffic')\n```\n\n\n\n\n","source":"_posts/angular-translate.md","raw":"---\ntitle: angular国际化方案\ndate: 2020-05-09 17:30:05\nexcerpt: angular\ntags:\nposition:\nimage_url:\n---\n\nAngular 国际化常见有 Angular 内置和基于 @ngx-translate/core （请参考官网了解更多实现细节）两种不同国际化方案。\n\n### 两种方案\n###### 1、Angular 内置（多个app）\nAngular 文档（中文版）有完整的描述，注意需要为每一种语言构建和部署单独的应用程序版本。\n\n###### 2、@ngx-translate/core（推荐，只用一套app）\n@ngx-translate/core 是社区版本的 Angular 国际化，相比较 Angular 内置它是动态性，无须针对不同语言构建和部署单独版本，并且大部分情况下可以立即呈现。\n\n---\n### @ngx-translate/core使用\n###### 1、html中\n```\n<a>{{ 'menu.fullscreen' | i18n}}</a>\n```\n\n###### 2、ts中,动态引入语言包，获取其中的文字\n```\nthis.i18n.fanyi('app.analysis.traffic')\n```\n\n\n\n\n","slug":"angular-translate","published":1,"updated":"2021-05-10T09:33:14.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmn00081kwafsc7bejg","content":"<p>Angular 国际化常见有 Angular 内置和基于 @ngx-translate/core （请参考官网了解更多实现细节）两种不同国际化方案。</p>\n<h3 id=\"两种方案\"><a href=\"#两种方案\" class=\"headerlink\" title=\"两种方案\"></a>两种方案</h3><h6 id=\"1、Angular-内置（多个app）\"><a href=\"#1、Angular-内置（多个app）\" class=\"headerlink\" title=\"1、Angular 内置（多个app）\"></a>1、Angular 内置（多个app）</h6><p>Angular 文档（中文版）有完整的描述，注意需要为每一种语言构建和部署单独的应用程序版本。</p>\n<h6 id=\"2、-ngx-translate-core（推荐，只用一套app）\"><a href=\"#2、-ngx-translate-core（推荐，只用一套app）\" class=\"headerlink\" title=\"2、@ngx-translate/core（推荐，只用一套app）\"></a>2、@ngx-translate/core（推荐，只用一套app）</h6><p>@ngx-translate/core 是社区版本的 Angular 国际化，相比较 Angular 内置它是动态性，无须针对不同语言构建和部署单独版本，并且大部分情况下可以立即呈现。</p>\n<hr>\n<h3 id=\"ngx-translate-core使用\"><a href=\"#ngx-translate-core使用\" class=\"headerlink\" title=\"@ngx-translate/core使用\"></a>@ngx-translate/core使用</h3><h6 id=\"1、html中\"><a href=\"#1、html中\" class=\"headerlink\" title=\"1、html中\"></a>1、html中</h6><figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span></span><span class=\"hljs-template-variable\">&#123;&#123; <span class=\"hljs-name\">&#x27;menu.fullscreen&#x27;</span> | i18n&#125;&#125;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h6 id=\"2、ts中-动态引入语言包，获取其中的文字\"><a href=\"#2、ts中-动态引入语言包，获取其中的文字\" class=\"headerlink\" title=\"2、ts中,动态引入语言包，获取其中的文字\"></a>2、ts中,动态引入语言包，获取其中的文字</h6><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">this</span>.i18n.fanyi(<span class=\"hljs-string\">&#x27;app.analysis.traffic&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"more":"<p>Angular 国际化常见有 Angular 内置和基于 @ngx-translate/core （请参考官网了解更多实现细节）两种不同国际化方案。</p>\n<h3 id=\"两种方案\"><a href=\"#两种方案\" class=\"headerlink\" title=\"两种方案\"></a>两种方案</h3><h6 id=\"1、Angular-内置（多个app）\"><a href=\"#1、Angular-内置（多个app）\" class=\"headerlink\" title=\"1、Angular 内置（多个app）\"></a>1、Angular 内置（多个app）</h6><p>Angular 文档（中文版）有完整的描述，注意需要为每一种语言构建和部署单独的应用程序版本。</p>\n<h6 id=\"2、-ngx-translate-core（推荐，只用一套app）\"><a href=\"#2、-ngx-translate-core（推荐，只用一套app）\" class=\"headerlink\" title=\"2、@ngx-translate/core（推荐，只用一套app）\"></a>2、@ngx-translate/core（推荐，只用一套app）</h6><p>@ngx-translate/core 是社区版本的 Angular 国际化，相比较 Angular 内置它是动态性，无须针对不同语言构建和部署单独版本，并且大部分情况下可以立即呈现。</p>\n<hr>\n<h3 id=\"ngx-translate-core使用\"><a href=\"#ngx-translate-core使用\" class=\"headerlink\" title=\"@ngx-translate/core使用\"></a>@ngx-translate/core使用</h3><h6 id=\"1、html中\"><a href=\"#1、html中\" class=\"headerlink\" title=\"1、html中\"></a>1、html中</h6><figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span></span><span class=\"hljs-template-variable\">&#123;&#123; <span class=\"hljs-name\">&#x27;menu.fullscreen&#x27;</span> | i18n&#125;&#125;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h6 id=\"2、ts中-动态引入语言包，获取其中的文字\"><a href=\"#2、ts中-动态引入语言包，获取其中的文字\" class=\"headerlink\" title=\"2、ts中,动态引入语言包，获取其中的文字\"></a>2、ts中,动态引入语言包，获取其中的文字</h6><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">this</span>.i18n.fanyi(<span class=\"hljs-string\">&#x27;app.analysis.traffic&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n\n"},{"title":"babel-loader的原理","date":"2020-07-10T08:01:17.000Z","excerpt":"Babel包的构成","position":null,"image_url":null,"_content":"#### es6转es5分为3步：\n1. 解析。词法分析和语法分析。\n    生成ES6语法树 语法分析，生成抽象语法树\n2. 转换。根据ES6 ast生成ES5 ast。\n3. 代码生成。根据ES5ast生成ES5代码\n\n###### 流程：\nes6代码的输入---》babelon进行解析---》得到AST--》plugin用babel-traverse对AST树进行遍历 ---》得到新的AST树 ---》使用babel-genertor通过AST树生成es5代码。\n\n#### Babel包的构成\n###### 核心包\n- babel-core：是babel转译器本身，提供转译的API，例如babel.transform等，webpack的babel-loader就是调用这些API完成转译的\n- babylon：js的词法解析器\n- babel-traverse：用于对AST（抽象语法树Abstract Syntax Tree）的遍历\n- babel-generator：根据AST生成代码\n\n###### 其他\n- babel-cli：用于命令行转码\n- babel-types：用于检验，构建和变更AST的节点\n- babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用\n- babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点\n- babel-code-frame：用于生成错误信息，打印出错误点源代码帧以及指出出错位置\n- babel-register：通过绑定node.js的require来完成自动编译\n- babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装\n- babel-runtime：类似于polyfill，但是不会污染全局变量\n\n##### polyfill与runtime的区别\n最主要的区别就是polyfill引入后，会将新的原生对象、API这些都直接引入到全局环境，这样就会污染全局变量，这也是polyfill的缺陷。所以就轮到babel-runtime上场了。\n\n##### transform-runtime和babel-runtime\ntransform-runtime是将js中使用到新的原生对象和静态方法转译成对babel-runtime的引用，而其中babel-runtime的功能其实最终也是由core-js来实现的，其实真正的核心是上面所讲的core-js，其他的都是包装。\n\n","source":"_posts/babel-loader.md","raw":"---\ntitle: babel-loader的原理\ndate: 2020-07-10 16:01:17\nexcerpt: Babel包的构成\ntags:\nposition:\nimage_url:\n---\n#### es6转es5分为3步：\n1. 解析。词法分析和语法分析。\n    生成ES6语法树 语法分析，生成抽象语法树\n2. 转换。根据ES6 ast生成ES5 ast。\n3. 代码生成。根据ES5ast生成ES5代码\n\n###### 流程：\nes6代码的输入---》babelon进行解析---》得到AST--》plugin用babel-traverse对AST树进行遍历 ---》得到新的AST树 ---》使用babel-genertor通过AST树生成es5代码。\n\n#### Babel包的构成\n###### 核心包\n- babel-core：是babel转译器本身，提供转译的API，例如babel.transform等，webpack的babel-loader就是调用这些API完成转译的\n- babylon：js的词法解析器\n- babel-traverse：用于对AST（抽象语法树Abstract Syntax Tree）的遍历\n- babel-generator：根据AST生成代码\n\n###### 其他\n- babel-cli：用于命令行转码\n- babel-types：用于检验，构建和变更AST的节点\n- babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用\n- babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点\n- babel-code-frame：用于生成错误信息，打印出错误点源代码帧以及指出出错位置\n- babel-register：通过绑定node.js的require来完成自动编译\n- babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装\n- babel-runtime：类似于polyfill，但是不会污染全局变量\n\n##### polyfill与runtime的区别\n最主要的区别就是polyfill引入后，会将新的原生对象、API这些都直接引入到全局环境，这样就会污染全局变量，这也是polyfill的缺陷。所以就轮到babel-runtime上场了。\n\n##### transform-runtime和babel-runtime\ntransform-runtime是将js中使用到新的原生对象和静态方法转译成对babel-runtime的引用，而其中babel-runtime的功能其实最终也是由core-js来实现的，其实真正的核心是上面所讲的core-js，其他的都是包装。\n\n","slug":"babel-loader","published":1,"updated":"2021-05-10T08:09:58.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmo00091kwahcbha9i4","content":"<h4 id=\"es6转es5分为3步：\"><a href=\"#es6转es5分为3步：\" class=\"headerlink\" title=\"es6转es5分为3步：\"></a>es6转es5分为3步：</h4><ol>\n<li>解析。词法分析和语法分析。<br> 生成ES6语法树 语法分析，生成抽象语法树</li>\n<li>转换。根据ES6 ast生成ES5 ast。</li>\n<li>代码生成。根据ES5ast生成ES5代码</li>\n</ol>\n<h6 id=\"流程：\"><a href=\"#流程：\" class=\"headerlink\" title=\"流程：\"></a>流程：</h6><p>es6代码的输入—》babelon进行解析—》得到AST–》plugin用babel-traverse对AST树进行遍历 —》得到新的AST树 —》使用babel-genertor通过AST树生成es5代码。</p>\n<h4 id=\"Babel包的构成\"><a href=\"#Babel包的构成\" class=\"headerlink\" title=\"Babel包的构成\"></a>Babel包的构成</h4><h6 id=\"核心包\"><a href=\"#核心包\" class=\"headerlink\" title=\"核心包\"></a>核心包</h6><ul>\n<li>babel-core：是babel转译器本身，提供转译的API，例如babel.transform等，webpack的babel-loader就是调用这些API完成转译的</li>\n<li>babylon：js的词法解析器</li>\n<li>babel-traverse：用于对AST（抽象语法树Abstract Syntax Tree）的遍历</li>\n<li>babel-generator：根据AST生成代码</li>\n</ul>\n<h6 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h6><ul>\n<li>babel-cli：用于命令行转码</li>\n<li>babel-types：用于检验，构建和变更AST的节点</li>\n<li>babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用</li>\n<li>babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点</li>\n<li>babel-code-frame：用于生成错误信息，打印出错误点源代码帧以及指出出错位置</li>\n<li>babel-register：通过绑定node.js的require来完成自动编译</li>\n<li>babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装</li>\n<li>babel-runtime：类似于polyfill，但是不会污染全局变量</li>\n</ul>\n<h5 id=\"polyfill与runtime的区别\"><a href=\"#polyfill与runtime的区别\" class=\"headerlink\" title=\"polyfill与runtime的区别\"></a>polyfill与runtime的区别</h5><p>最主要的区别就是polyfill引入后，会将新的原生对象、API这些都直接引入到全局环境，这样就会污染全局变量，这也是polyfill的缺陷。所以就轮到babel-runtime上场了。</p>\n<h5 id=\"transform-runtime和babel-runtime\"><a href=\"#transform-runtime和babel-runtime\" class=\"headerlink\" title=\"transform-runtime和babel-runtime\"></a>transform-runtime和babel-runtime</h5><p>transform-runtime是将js中使用到新的原生对象和静态方法转译成对babel-runtime的引用，而其中babel-runtime的功能其实最终也是由core-js来实现的，其实真正的核心是上面所讲的core-js，其他的都是包装。</p>\n","site":{"data":{}},"more":"<h4 id=\"es6转es5分为3步：\"><a href=\"#es6转es5分为3步：\" class=\"headerlink\" title=\"es6转es5分为3步：\"></a>es6转es5分为3步：</h4><ol>\n<li>解析。词法分析和语法分析。<br> 生成ES6语法树 语法分析，生成抽象语法树</li>\n<li>转换。根据ES6 ast生成ES5 ast。</li>\n<li>代码生成。根据ES5ast生成ES5代码</li>\n</ol>\n<h6 id=\"流程：\"><a href=\"#流程：\" class=\"headerlink\" title=\"流程：\"></a>流程：</h6><p>es6代码的输入—》babelon进行解析—》得到AST–》plugin用babel-traverse对AST树进行遍历 —》得到新的AST树 —》使用babel-genertor通过AST树生成es5代码。</p>\n<h4 id=\"Babel包的构成\"><a href=\"#Babel包的构成\" class=\"headerlink\" title=\"Babel包的构成\"></a>Babel包的构成</h4><h6 id=\"核心包\"><a href=\"#核心包\" class=\"headerlink\" title=\"核心包\"></a>核心包</h6><ul>\n<li>babel-core：是babel转译器本身，提供转译的API，例如babel.transform等，webpack的babel-loader就是调用这些API完成转译的</li>\n<li>babylon：js的词法解析器</li>\n<li>babel-traverse：用于对AST（抽象语法树Abstract Syntax Tree）的遍历</li>\n<li>babel-generator：根据AST生成代码</li>\n</ul>\n<h6 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h6><ul>\n<li>babel-cli：用于命令行转码</li>\n<li>babel-types：用于检验，构建和变更AST的节点</li>\n<li>babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用</li>\n<li>babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点</li>\n<li>babel-code-frame：用于生成错误信息，打印出错误点源代码帧以及指出出错位置</li>\n<li>babel-register：通过绑定node.js的require来完成自动编译</li>\n<li>babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装</li>\n<li>babel-runtime：类似于polyfill，但是不会污染全局变量</li>\n</ul>\n<h5 id=\"polyfill与runtime的区别\"><a href=\"#polyfill与runtime的区别\" class=\"headerlink\" title=\"polyfill与runtime的区别\"></a>polyfill与runtime的区别</h5><p>最主要的区别就是polyfill引入后，会将新的原生对象、API这些都直接引入到全局环境，这样就会污染全局变量，这也是polyfill的缺陷。所以就轮到babel-runtime上场了。</p>\n<h5 id=\"transform-runtime和babel-runtime\"><a href=\"#transform-runtime和babel-runtime\" class=\"headerlink\" title=\"transform-runtime和babel-runtime\"></a>transform-runtime和babel-runtime</h5><p>transform-runtime是将js中使用到新的原生对象和静态方法转译成对babel-runtime的引用，而其中babel-runtime的功能其实最终也是由core-js来实现的，其实真正的核心是上面所讲的core-js，其他的都是包装。</p>\n"},{"title":"JS中 [] == ![]结果为true，而 {} == !{}却为false","date":"2019-03-10T09:41:40.000Z","excerpt":"js操作符比较","position":null,"image_url":null,"_content":"### 类型基本转换规则：\n1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；\n2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值\n3. 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()\n\n### 这两个操作符在进行比较时则要遵循下列规则\n1. null 和undefined 是相等的\n2. 要比较相等性之前，不能将null 和 undefined 转换成其他任何值\n3. 如果有一个操作数是NaN，则相等操作符返回 false ，而不相等操作符返回 true。重要提示：即使两个操作数都是NaN，相等操作符也返回 false了；因为按照规则， NaN 不等于 NaN\n4. 如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true；否则， 返回false\n\n### 例子\n#### [] == ! [] \n[] == ! []   ->   [] == false  ->  [] == 0  ->   '' == 0   ->  0 == 0   ->  true\n\n#### {} == !{}\n{} == !{}  ->  {} == false  -> {} == 0 ->  NaN == 0  ->  false  \n","source":"_posts/compare.md","raw":"---\ntitle: JS中 [] == ![]结果为true，而 {} == !{}却为false\ndate: 2019-03-10 17:41:40\nexcerpt: js操作符比较\ntags: js\nposition:\nimage_url:\n---\n### 类型基本转换规则：\n1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；\n2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值\n3. 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()\n\n### 这两个操作符在进行比较时则要遵循下列规则\n1. null 和undefined 是相等的\n2. 要比较相等性之前，不能将null 和 undefined 转换成其他任何值\n3. 如果有一个操作数是NaN，则相等操作符返回 false ，而不相等操作符返回 true。重要提示：即使两个操作数都是NaN，相等操作符也返回 false了；因为按照规则， NaN 不等于 NaN\n4. 如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true；否则， 返回false\n\n### 例子\n#### [] == ! [] \n[] == ! []   ->   [] == false  ->  [] == 0  ->   '' == 0   ->  0 == 0   ->  true\n\n#### {} == !{}\n{} == !{}  ->  {} == false  -> {} == 0 ->  NaN == 0  ->  false  \n","slug":"compare","published":1,"updated":"2021-05-11T01:57:29.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmp000a1kwa9aag3cr1","content":"<h3 id=\"类型基本转换规则：\"><a href=\"#类型基本转换规则：\" class=\"headerlink\" title=\"类型基本转换规则：\"></a>类型基本转换规则：</h3><ol>\n<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>\n<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值</li>\n<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()</li>\n</ol>\n<h3 id=\"这两个操作符在进行比较时则要遵循下列规则\"><a href=\"#这两个操作符在进行比较时则要遵循下列规则\" class=\"headerlink\" title=\"这两个操作符在进行比较时则要遵循下列规则\"></a>这两个操作符在进行比较时则要遵循下列规则</h3><ol>\n<li>null 和undefined 是相等的</li>\n<li>要比较相等性之前，不能将null 和 undefined 转换成其他任何值</li>\n<li>如果有一个操作数是NaN，则相等操作符返回 false ，而不相等操作符返回 true。重要提示：即使两个操作数都是NaN，相等操作符也返回 false了；因为按照规则， NaN 不等于 NaN</li>\n<li>如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true；否则， 返回false</li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"[] == ! []\"></a>[] == ! []</h4><p>[] == ! []   -&gt;   [] == false  -&gt;  [] == 0  -&gt;   ‘’ == 0   -&gt;  0 == 0   -&gt;  true</p>\n<h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"{} == !{}\"></a>{} == !{}</h4><p>{} == !{}  -&gt;  {} == false  -&gt; {} == 0 -&gt;  NaN == 0  -&gt;  false  </p>\n","site":{"data":{}},"more":"<h3 id=\"类型基本转换规则：\"><a href=\"#类型基本转换规则：\" class=\"headerlink\" title=\"类型基本转换规则：\"></a>类型基本转换规则：</h3><ol>\n<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>\n<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值</li>\n<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()</li>\n</ol>\n<h3 id=\"这两个操作符在进行比较时则要遵循下列规则\"><a href=\"#这两个操作符在进行比较时则要遵循下列规则\" class=\"headerlink\" title=\"这两个操作符在进行比较时则要遵循下列规则\"></a>这两个操作符在进行比较时则要遵循下列规则</h3><ol>\n<li>null 和undefined 是相等的</li>\n<li>要比较相等性之前，不能将null 和 undefined 转换成其他任何值</li>\n<li>如果有一个操作数是NaN，则相等操作符返回 false ，而不相等操作符返回 true。重要提示：即使两个操作数都是NaN，相等操作符也返回 false了；因为按照规则， NaN 不等于 NaN</li>\n<li>如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true；否则， 返回false</li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"[] == ! []\"></a>[] == ! []</h4><p>[] == ! []   -&gt;   [] == false  -&gt;  [] == 0  -&gt;   ‘’ == 0   -&gt;  0 == 0   -&gt;  true</p>\n<h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"{} == !{}\"></a>{} == !{}</h4><p>{} == !{}  -&gt;  {} == false  -&gt; {} == 0 -&gt;  NaN == 0  -&gt;  false  </p>\n"},{"title":"异步调度任务，同一时间限制输出。","date":"2021-05-11T02:17:39.000Z","excerpt":"异步调度任务，同一时间限制输出。","index_img":"/images/dark.jpeg","_content":"\n```\nclass Scheduler {\n    list = [];\n\n    count = 0;\n\n    constructor(num) {\n        this.num = num;\n    }\n\n    async add(fn) {//fn是一个异步函数，返回\n        if (this.count >= this.num) {\n            await new Promise((resolve) => {\n                this.list.push(resolve);\n            });\n        }\n\n        this.count++;\n\n        let res = await fn();\n\n        this.count--;\n\n        if (this.list.length > 0) {\n            this.list.shift()();\n        }\n\n        return res;\n    }\n}\n\n//以下是调用执行\nconst schedule = new Scheduler(2);//最多同一时间让它执行3个异步函数\n\nconst asyncFacotory = (n, time) => {\n\n    return () => {\n\n        return new Promise((resolve) => {\n\n            setTimeout(() => {\n                resolve(n);\n            }, time)\n\n        })\n\n    }\n\n}\n\nschedule.add(asyncFacotory(1, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(2, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(3, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(4, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(5, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(6, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\n```\n","source":"_posts/async-schedule.md","raw":"---\ntitle: 异步调度任务，同一时间限制输出。\ndate: 2021-05-11 10:17:39\nexcerpt: 异步调度任务，同一时间限制输出。\ntags: interview\ncategories: 项目相关\nindex_img: /images/dark.jpeg\n---\n\n```\nclass Scheduler {\n    list = [];\n\n    count = 0;\n\n    constructor(num) {\n        this.num = num;\n    }\n\n    async add(fn) {//fn是一个异步函数，返回\n        if (this.count >= this.num) {\n            await new Promise((resolve) => {\n                this.list.push(resolve);\n            });\n        }\n\n        this.count++;\n\n        let res = await fn();\n\n        this.count--;\n\n        if (this.list.length > 0) {\n            this.list.shift()();\n        }\n\n        return res;\n    }\n}\n\n//以下是调用执行\nconst schedule = new Scheduler(2);//最多同一时间让它执行3个异步函数\n\nconst asyncFacotory = (n, time) => {\n\n    return () => {\n\n        return new Promise((resolve) => {\n\n            setTimeout(() => {\n                resolve(n);\n            }, time)\n\n        })\n\n    }\n\n}\n\nschedule.add(asyncFacotory(1, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(2, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(3, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(4, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(5, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\nschedule.add(asyncFacotory(6, 2000)).then((n) => {\n    console.log(`异步任务:${n}`)\n});\n```\n","slug":"async-schedule","published":1,"updated":"2021-05-11T06:45:18.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmr000b1kwa0o3q88m0","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Scheduler</span> </span>&#123;<br>    list = [];<br><br>    count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">num</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.num = num;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">fn</span>)</span> &#123;<span class=\"hljs-comment\">//fn是一个异步函数，返回</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.count &gt;= <span class=\"hljs-built_in\">this</span>.num) &#123;<br>            <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>                <span class=\"hljs-built_in\">this</span>.list.push(resolve);<br>            &#125;);<br>        &#125;<br><br>        <span class=\"hljs-built_in\">this</span>.count++;<br><br>        <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-keyword\">await</span> fn();<br><br>        <span class=\"hljs-built_in\">this</span>.count--;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.list.length &gt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">this</span>.list.shift()();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//以下是调用执行</span><br><span class=\"hljs-keyword\">const</span> schedule = <span class=\"hljs-keyword\">new</span> Scheduler(<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//最多同一时间让它执行3个异步函数</span><br><br><span class=\"hljs-keyword\">const</span> asyncFacotory = <span class=\"hljs-function\">(<span class=\"hljs-params\">n, time</span>) =&gt;</span> &#123;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br><br>            <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>                resolve(n);<br>            &#125;, time)<br><br>        &#125;)<br><br>    &#125;<br><br>&#125;<br><br>schedule.add(asyncFacotory(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Scheduler</span> </span>&#123;<br>    list = [];<br><br>    count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">num</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.num = num;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">fn</span>)</span> &#123;<span class=\"hljs-comment\">//fn是一个异步函数，返回</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.count &gt;= <span class=\"hljs-built_in\">this</span>.num) &#123;<br>            <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>                <span class=\"hljs-built_in\">this</span>.list.push(resolve);<br>            &#125;);<br>        &#125;<br><br>        <span class=\"hljs-built_in\">this</span>.count++;<br><br>        <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-keyword\">await</span> fn();<br><br>        <span class=\"hljs-built_in\">this</span>.count--;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.list.length &gt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">this</span>.list.shift()();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//以下是调用执行</span><br><span class=\"hljs-keyword\">const</span> schedule = <span class=\"hljs-keyword\">new</span> Scheduler(<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//最多同一时间让它执行3个异步函数</span><br><br><span class=\"hljs-keyword\">const</span> asyncFacotory = <span class=\"hljs-function\">(<span class=\"hljs-params\">n, time</span>) =&gt;</span> &#123;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br><br>            <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>                resolve(n);<br>            &#125;, time)<br><br>        &#125;)<br><br>    &#125;<br><br>&#125;<br><br>schedule.add(asyncFacotory(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br>schedule.add(asyncFacotory(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2000</span>)).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`异步任务:<span class=\"hljs-subst\">$&#123;n&#125;</span>`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n"},{"title":"css3动画","date":"2021-01-11T07:04:21.000Z","excerpt":"transition、animation、transform的区别","position":null,"image_url":null,"_content":"\n## 一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\n###### 属性是一个简写属性，用于设置四个过渡属性：  \n- transition-property  - css属性\n- transition-duration   - 动画执行时长 如果为0 动画不执行\n- transition-timing-function    - 动画执行方式 默认ease\n- transition-delay   - 动画延迟执行时间 默认0\n\n一般来说，将transition属性应用到最初的样式里，而不是放在结束的样式里，即定义动画开始之前的元素外观的样式。\n\n只需要给元素设置一次transition，浏览器就会负责以动画展示从一个样式到另一个样式，再返回最初样式的变化过程。它的特性：\n\n1. 需要一个事件来触发，比如hover，所以没法在网页加载时自动触发。\n2. 是一次性的，不能重复发生，除非一再触发。\n3. 只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。\n4. 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。\n\n为了突破这些限制，animation出现了。\n\n## 二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值\n###### 属性是一个简写属性，用于设置六个动画属性：\n- animation-name  规定需要绑定到选择器的 keyframe 名称。\n- animation-duration\n- animation-timing-function\n- animation-delay  \n- animation-iteration-count   - 规定动画应该播放的次数。  n | infinite\n- animation-direction   - 规定是否应该轮流反向播放动画。 normal | alternate;\n\n一般来说，会结合animation-play-state使用\n\n#### 规定动画正在运行还是暂停\n\n```\nanimation-play-state: paused|running;\n```\n\n## 三、transform：\n###### 向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\n\n```\ntransform: none|transform-functions;\n\ntransform-functions:\n    matrix():定义矩阵变换。\n    translate():移动元素对象。\n    scale():缩放元素对象。\n    rotate():旋转元素对象。\n    skew():倾斜元素对象。\n\n\ntranslate(a, b)：是transform中的一个属性，用官方的话说叫做2D转移，其实就是平面上的x轴和y轴移动，具体使用：\ntransform: translate(x,y)\ntransform: translateX(x)\ntransform: translateY(y)\n```\n\n## 四、渐变：\n\n```\nlinear-gradient(方向，颜色1，颜色2，...)\n\n实例：\nbackground: linear-gradient(90deg,red 0px,green 25%,blue 50%, purple 75%);\n\nbackground: linear-gradient(red,green,blue);\n\nbackground: linear-gradient(red 0px,green 25%,blue 50%, purple 75%);\n```\n\n","source":"_posts/css-animation.md","raw":"---\ntitle: css3动画\ndate: 2021-01-11 15:04:21\nexcerpt: transition、animation、transform的区别\ntags: css\nposition:\nimage_url:\n---\n\n## 一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\n###### 属性是一个简写属性，用于设置四个过渡属性：  \n- transition-property  - css属性\n- transition-duration   - 动画执行时长 如果为0 动画不执行\n- transition-timing-function    - 动画执行方式 默认ease\n- transition-delay   - 动画延迟执行时间 默认0\n\n一般来说，将transition属性应用到最初的样式里，而不是放在结束的样式里，即定义动画开始之前的元素外观的样式。\n\n只需要给元素设置一次transition，浏览器就会负责以动画展示从一个样式到另一个样式，再返回最初样式的变化过程。它的特性：\n\n1. 需要一个事件来触发，比如hover，所以没法在网页加载时自动触发。\n2. 是一次性的，不能重复发生，除非一再触发。\n3. 只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。\n4. 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。\n\n为了突破这些限制，animation出现了。\n\n## 二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值\n###### 属性是一个简写属性，用于设置六个动画属性：\n- animation-name  规定需要绑定到选择器的 keyframe 名称。\n- animation-duration\n- animation-timing-function\n- animation-delay  \n- animation-iteration-count   - 规定动画应该播放的次数。  n | infinite\n- animation-direction   - 规定是否应该轮流反向播放动画。 normal | alternate;\n\n一般来说，会结合animation-play-state使用\n\n#### 规定动画正在运行还是暂停\n\n```\nanimation-play-state: paused|running;\n```\n\n## 三、transform：\n###### 向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\n\n```\ntransform: none|transform-functions;\n\ntransform-functions:\n    matrix():定义矩阵变换。\n    translate():移动元素对象。\n    scale():缩放元素对象。\n    rotate():旋转元素对象。\n    skew():倾斜元素对象。\n\n\ntranslate(a, b)：是transform中的一个属性，用官方的话说叫做2D转移，其实就是平面上的x轴和y轴移动，具体使用：\ntransform: translate(x,y)\ntransform: translateX(x)\ntransform: translateY(y)\n```\n\n## 四、渐变：\n\n```\nlinear-gradient(方向，颜色1，颜色2，...)\n\n实例：\nbackground: linear-gradient(90deg,red 0px,green 25%,blue 50%, purple 75%);\n\nbackground: linear-gradient(red,green,blue);\n\nbackground: linear-gradient(red 0px,green 25%,blue 50%, purple 75%);\n```\n\n","slug":"css-animation","published":1,"updated":"2021-05-10T07:34:36.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmv000d1kwa016vdsk9","content":"<h2 id=\"一、transition-（动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\"><a href=\"#一、transition-（动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\" class=\"headerlink\" title=\"一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\"></a>一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。</h2><h6 id=\"属性是一个简写属性，用于设置四个过渡属性：\"><a href=\"#属性是一个简写属性，用于设置四个过渡属性：\" class=\"headerlink\" title=\"属性是一个简写属性，用于设置四个过渡属性：\"></a>属性是一个简写属性，用于设置四个过渡属性：</h6><ul>\n<li>transition-property  - css属性</li>\n<li>transition-duration   - 动画执行时长 如果为0 动画不执行</li>\n<li>transition-timing-function    - 动画执行方式 默认ease</li>\n<li>transition-delay   - 动画延迟执行时间 默认0</li>\n</ul>\n<p>一般来说，将transition属性应用到最初的样式里，而不是放在结束的样式里，即定义动画开始之前的元素外观的样式。</p>\n<p>只需要给元素设置一次transition，浏览器就会负责以动画展示从一个样式到另一个样式，再返回最初样式的变化过程。它的特性：</p>\n<ol>\n<li>需要一个事件来触发，比如hover，所以没法在网页加载时自动触发。</li>\n<li>是一次性的，不能重复发生，除非一再触发。</li>\n<li>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>\n<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>\n</ol>\n<p>为了突破这些限制，animation出现了。</p>\n<h2 id=\"二、animation-（动画属性）：animation可以通过keyframes显式控制当前帧的属性值\"><a href=\"#二、animation-（动画属性）：animation可以通过keyframes显式控制当前帧的属性值\" class=\"headerlink\" title=\"二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值\"></a>二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值</h2><h6 id=\"属性是一个简写属性，用于设置六个动画属性：\"><a href=\"#属性是一个简写属性，用于设置六个动画属性：\" class=\"headerlink\" title=\"属性是一个简写属性，用于设置六个动画属性：\"></a>属性是一个简写属性，用于设置六个动画属性：</h6><ul>\n<li>animation-name  规定需要绑定到选择器的 keyframe 名称。</li>\n<li>animation-duration</li>\n<li>animation-timing-function</li>\n<li>animation-delay  </li>\n<li>animation-iteration-count   - 规定动画应该播放的次数。  n | infinite</li>\n<li>animation-direction   - 规定是否应该轮流反向播放动画。 normal | alternate;</li>\n</ul>\n<p>一般来说，会结合animation-play-state使用</p>\n<h4 id=\"规定动画正在运行还是暂停\"><a href=\"#规定动画正在运行还是暂停\" class=\"headerlink\" title=\"规定动画正在运行还是暂停\"></a>规定动画正在运行还是暂停</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">animation-play-state</span>: paused|running;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、transform：\"><a href=\"#三、transform：\" class=\"headerlink\" title=\"三、transform：\"></a>三、transform：</h2><h6 id=\"向元素应用-2D-或-3D-转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\"><a href=\"#向元素应用-2D-或-3D-转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\" class=\"headerlink\" title=\"向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\"></a>向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</h6><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">transform</span>: none|<span class=\"hljs-built_in\">transform</span>-<span class=\"hljs-built_in\">functions</span>;<br><br><span class=\"hljs-built_in\">transform</span>-<span class=\"hljs-built_in\">functions</span>:<br>    <span class=\"hljs-built_in\">matrix</span>():定义矩阵变换。<br>    <span class=\"hljs-built_in\">translate</span>():移动元素对象。<br>    <span class=\"hljs-built_in\">scale</span>():缩放元素对象。<br>    rotate():旋转元素对象。<br>    skew():倾斜元素对象。<br><br><br><span class=\"hljs-built_in\">translate</span>(a, b)：是<span class=\"hljs-built_in\">transform</span>中的一个属性，用官方的话说叫做2D转移，其实就是平面上的x轴和y轴移动，具体使用：<br><span class=\"hljs-built_in\">transform</span>: <span class=\"hljs-built_in\">translate</span>(x,y)<br><span class=\"hljs-built_in\">transform</span>: translateX(x)<br><span class=\"hljs-built_in\">transform</span>: translateY(y)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、渐变：\"><a href=\"#四、渐变：\" class=\"headerlink\" title=\"四、渐变：\"></a>四、渐变：</h2><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">linear-gradient(方向，颜色<span class=\"hljs-number\">1</span>，颜色<span class=\"hljs-number\">2</span>，...)<br><br>实例：<br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-number\">90</span>deg,<span class=\"hljs-built_in\">red</span> <span class=\"hljs-number\">0</span>px,<span class=\"hljs-built_in\">green</span> <span class=\"hljs-number\">25</span>%,<span class=\"hljs-built_in\">blue</span> <span class=\"hljs-number\">50</span>%, purple <span class=\"hljs-number\">75</span>%);<br><br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-built_in\">red</span>,<span class=\"hljs-built_in\">green</span>,<span class=\"hljs-built_in\">blue</span>);<br><br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-built_in\">red</span> <span class=\"hljs-number\">0</span>px,<span class=\"hljs-built_in\">green</span> <span class=\"hljs-number\">25</span>%,<span class=\"hljs-built_in\">blue</span> <span class=\"hljs-number\">50</span>%, purple <span class=\"hljs-number\">75</span>%);<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<h2 id=\"一、transition-（动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\"><a href=\"#一、transition-（动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\" class=\"headerlink\" title=\"一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。\"></a>一、transition （动画过渡）：一定时间之内，一组css属性变换到另一组属性的动画展示过程。</h2><h6 id=\"属性是一个简写属性，用于设置四个过渡属性：\"><a href=\"#属性是一个简写属性，用于设置四个过渡属性：\" class=\"headerlink\" title=\"属性是一个简写属性，用于设置四个过渡属性：\"></a>属性是一个简写属性，用于设置四个过渡属性：</h6><ul>\n<li>transition-property  - css属性</li>\n<li>transition-duration   - 动画执行时长 如果为0 动画不执行</li>\n<li>transition-timing-function    - 动画执行方式 默认ease</li>\n<li>transition-delay   - 动画延迟执行时间 默认0</li>\n</ul>\n<p>一般来说，将transition属性应用到最初的样式里，而不是放在结束的样式里，即定义动画开始之前的元素外观的样式。</p>\n<p>只需要给元素设置一次transition，浏览器就会负责以动画展示从一个样式到另一个样式，再返回最初样式的变化过程。它的特性：</p>\n<ol>\n<li>需要一个事件来触发，比如hover，所以没法在网页加载时自动触发。</li>\n<li>是一次性的，不能重复发生，除非一再触发。</li>\n<li>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>\n<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>\n</ol>\n<p>为了突破这些限制，animation出现了。</p>\n<h2 id=\"二、animation-（动画属性）：animation可以通过keyframes显式控制当前帧的属性值\"><a href=\"#二、animation-（动画属性）：animation可以通过keyframes显式控制当前帧的属性值\" class=\"headerlink\" title=\"二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值\"></a>二、animation （动画属性）：animation可以通过keyframes显式控制当前帧的属性值</h2><h6 id=\"属性是一个简写属性，用于设置六个动画属性：\"><a href=\"#属性是一个简写属性，用于设置六个动画属性：\" class=\"headerlink\" title=\"属性是一个简写属性，用于设置六个动画属性：\"></a>属性是一个简写属性，用于设置六个动画属性：</h6><ul>\n<li>animation-name  规定需要绑定到选择器的 keyframe 名称。</li>\n<li>animation-duration</li>\n<li>animation-timing-function</li>\n<li>animation-delay  </li>\n<li>animation-iteration-count   - 规定动画应该播放的次数。  n | infinite</li>\n<li>animation-direction   - 规定是否应该轮流反向播放动画。 normal | alternate;</li>\n</ul>\n<p>一般来说，会结合animation-play-state使用</p>\n<h4 id=\"规定动画正在运行还是暂停\"><a href=\"#规定动画正在运行还是暂停\" class=\"headerlink\" title=\"规定动画正在运行还是暂停\"></a>规定动画正在运行还是暂停</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">animation-play-state</span>: paused|running;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、transform：\"><a href=\"#三、transform：\" class=\"headerlink\" title=\"三、transform：\"></a>三、transform：</h2><h6 id=\"向元素应用-2D-或-3D-转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\"><a href=\"#向元素应用-2D-或-3D-转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\" class=\"headerlink\" title=\"向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\"></a>向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</h6><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">transform</span>: none|<span class=\"hljs-built_in\">transform</span>-<span class=\"hljs-built_in\">functions</span>;<br><br><span class=\"hljs-built_in\">transform</span>-<span class=\"hljs-built_in\">functions</span>:<br>    <span class=\"hljs-built_in\">matrix</span>():定义矩阵变换。<br>    <span class=\"hljs-built_in\">translate</span>():移动元素对象。<br>    <span class=\"hljs-built_in\">scale</span>():缩放元素对象。<br>    rotate():旋转元素对象。<br>    skew():倾斜元素对象。<br><br><br><span class=\"hljs-built_in\">translate</span>(a, b)：是<span class=\"hljs-built_in\">transform</span>中的一个属性，用官方的话说叫做2D转移，其实就是平面上的x轴和y轴移动，具体使用：<br><span class=\"hljs-built_in\">transform</span>: <span class=\"hljs-built_in\">translate</span>(x,y)<br><span class=\"hljs-built_in\">transform</span>: translateX(x)<br><span class=\"hljs-built_in\">transform</span>: translateY(y)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、渐变：\"><a href=\"#四、渐变：\" class=\"headerlink\" title=\"四、渐变：\"></a>四、渐变：</h2><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">linear-gradient(方向，颜色<span class=\"hljs-number\">1</span>，颜色<span class=\"hljs-number\">2</span>，...)<br><br>实例：<br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-number\">90</span>deg,<span class=\"hljs-built_in\">red</span> <span class=\"hljs-number\">0</span>px,<span class=\"hljs-built_in\">green</span> <span class=\"hljs-number\">25</span>%,<span class=\"hljs-built_in\">blue</span> <span class=\"hljs-number\">50</span>%, purple <span class=\"hljs-number\">75</span>%);<br><br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-built_in\">red</span>,<span class=\"hljs-built_in\">green</span>,<span class=\"hljs-built_in\">blue</span>);<br><br><span class=\"hljs-built_in\">background</span>: linear-gradient(<span class=\"hljs-built_in\">red</span> <span class=\"hljs-number\">0</span>px,<span class=\"hljs-built_in\">green</span> <span class=\"hljs-number\">25</span>%,<span class=\"hljs-built_in\">blue</span> <span class=\"hljs-number\">50</span>%, purple <span class=\"hljs-number\">75</span>%);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"前端构建工具原理分析","date":"2021-03-07T09:56:44.000Z","_content":"\n[前端构建工具原理分析.pdf](/file/goujian.pdf)\n","source":"_posts/build-tools.md","raw":"---\ntitle: 前端构建工具原理分析\ndate: 2021-03-07 17:56:44\ntags:\n---\n\n[前端构建工具原理分析.pdf](/file/goujian.pdf)\n","slug":"build-tools","published":1,"updated":"2021-05-08T07:47:18.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmx000f1kwab7it6yla","content":"<p><a href=\"/file/goujian.pdf\">前端构建工具原理分析.pdf</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"/file/goujian.pdf\">前端构建工具原理分析.pdf</a></p>\n"},{"title":"重排、重绘","date":"2021-04-10T06:56:19.000Z","excerpt":"重排（回流）和重绘","position":null,"image_url":null,"_content":"\n## 重排\n概念：页面中元素样式的改**变影响它在文档流中的位置**\n###### 引起重排的操作\n- 页面首次渲染\n- 浏览器窗口大小发生变化\n- 元素尺寸或位置发生变化\n- 元素内容变化（文字数量或图片大小等等）\n- 元素字体大小变化\n- 添加或删除了可见的dom元素\n- 激活css伪类\n\n\n\n## 重绘\n概念：当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。\n###### 引起重绘的操作\n- color\n- background\n- visibility\n\n## 减少重绘/重排\n- 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；\n- 动画尽量使用在绝对定位或固定定位的元素上；\n- 用事件委托来减少事件处理器的数量。\n\n\n","source":"_posts/backflow-and-redraw.md","raw":"---\ntitle: 重排、重绘\ndate: 2021-04-10 14:56:19\nexcerpt: 重排（回流）和重绘\ntags: 重排,重绘\nposition:\nimage_url:\n---\n\n## 重排\n概念：页面中元素样式的改**变影响它在文档流中的位置**\n###### 引起重排的操作\n- 页面首次渲染\n- 浏览器窗口大小发生变化\n- 元素尺寸或位置发生变化\n- 元素内容变化（文字数量或图片大小等等）\n- 元素字体大小变化\n- 添加或删除了可见的dom元素\n- 激活css伪类\n\n\n\n## 重绘\n概念：当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。\n###### 引起重绘的操作\n- color\n- background\n- visibility\n\n## 减少重绘/重排\n- 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；\n- 动画尽量使用在绝对定位或固定定位的元素上；\n- 用事件委托来减少事件处理器的数量。\n\n\n","slug":"backflow-and-redraw","published":1,"updated":"2021-05-10T06:58:20.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkmz000g1kwa2rqce7qf","content":"<h2 id=\"重排\"><a href=\"#重排\" class=\"headerlink\" title=\"重排\"></a>重排</h2><p>概念：页面中元素样式的改<strong>变影响它在文档流中的位置</strong></p>\n<h6 id=\"引起重排的操作\"><a href=\"#引起重排的操作\" class=\"headerlink\" title=\"引起重排的操作\"></a>引起重排的操作</h6><ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生变化</li>\n<li>元素尺寸或位置发生变化</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或删除了可见的dom元素</li>\n<li>激活css伪类</li>\n</ul>\n<h2 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h2><p>概念：当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</p>\n<h6 id=\"引起重绘的操作\"><a href=\"#引起重绘的操作\" class=\"headerlink\" title=\"引起重绘的操作\"></a>引起重绘的操作</h6><ul>\n<li>color</li>\n<li>background</li>\n<li>visibility</li>\n</ul>\n<h2 id=\"减少重绘-重排\"><a href=\"#减少重绘-重排\" class=\"headerlink\" title=\"减少重绘/重排\"></a>减少重绘/重排</h2><ul>\n<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>\n<li>动画尽量使用在绝对定位或固定定位的元素上；</li>\n<li>用事件委托来减少事件处理器的数量。</li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"重排\"><a href=\"#重排\" class=\"headerlink\" title=\"重排\"></a>重排</h2><p>概念：页面中元素样式的改<strong>变影响它在文档流中的位置</strong></p>\n<h6 id=\"引起重排的操作\"><a href=\"#引起重排的操作\" class=\"headerlink\" title=\"引起重排的操作\"></a>引起重排的操作</h6><ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生变化</li>\n<li>元素尺寸或位置发生变化</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或删除了可见的dom元素</li>\n<li>激活css伪类</li>\n</ul>\n<h2 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h2><p>概念：当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</p>\n<h6 id=\"引起重绘的操作\"><a href=\"#引起重绘的操作\" class=\"headerlink\" title=\"引起重绘的操作\"></a>引起重绘的操作</h6><ul>\n<li>color</li>\n<li>background</li>\n<li>visibility</li>\n</ul>\n<h2 id=\"减少重绘-重排\"><a href=\"#减少重绘-重排\" class=\"headerlink\" title=\"减少重绘/重排\"></a>减少重绘/重排</h2><ul>\n<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>\n<li>动画尽量使用在绝对定位或固定定位的元素上；</li>\n<li>用事件委托来减少事件处理器的数量。</li>\n</ul>\n"},{"title":"单行、多行超出","date":"2020-03-24T07:36:56.000Z","excerpt":"单行、多行超出","position":null,"image_url":null,"_content":"#### 单行\n```\np{\n    overflow:hidden;\n    text-overflow:ellipsis;\n    white-space:nowrap;\n}\n```\n\n#### 多行\n```\np{\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n}\n```\n\n#### 判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\n```\n<script>\n    function main() {\n      let box = document.querySelector('.box')\n      console.log(\"scrollWidth: \", box.scrollWidth)\n      console.log(\"offsetWidth: \", box.offsetWidth)\n      if (box.scrollWidth > box.offsetWidth) {\n        console.log(\"出现了省略号\")\n      } else {\n        console.log(\"没有出现省略号\")\n      }\n    }\n    main()\n  </script>\n```\n\n","source":"_posts/css-line.md","raw":"---\ntitle: 单行、多行超出\ndate: 2020-03-24 15:36:56\nexcerpt: 单行、多行超出\ntags: css\nposition:\nimage_url:\n---\n#### 单行\n```\np{\n    overflow:hidden;\n    text-overflow:ellipsis;\n    white-space:nowrap;\n}\n```\n\n#### 多行\n```\np{\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n}\n```\n\n#### 判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\n```\n<script>\n    function main() {\n      let box = document.querySelector('.box')\n      console.log(\"scrollWidth: \", box.scrollWidth)\n      console.log(\"offsetWidth: \", box.offsetWidth)\n      if (box.scrollWidth > box.offsetWidth) {\n        console.log(\"出现了省略号\")\n      } else {\n        console.log(\"没有出现省略号\")\n      }\n    }\n    main()\n  </script>\n```\n\n","slug":"css-line","published":1,"updated":"2021-05-10T07:40:14.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn0000j1kwabr2jcj9w","content":"<h4 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">overflow</span>:hidden;<br>    <span class=\"hljs-attribute\">text-overflow</span>:ellipsis;<br>    <span class=\"hljs-attribute\">white-space</span>:nowrap;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">display</span>: -webkit-box;<br>    -webkit-line-clamp: <span class=\"hljs-number\">2</span>;<br>    -webkit-box-orient: vertical;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\"><a href=\"#判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\" class=\"headerlink\" title=\"判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\"></a>判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"javascript\">      <span class=\"hljs-keyword\">let</span> box = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;.box&#x27;</span>)</span><br><span class=\"javascript\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;scrollWidth: &quot;</span>, box.scrollWidth)</span><br><span class=\"javascript\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;offsetWidth: &quot;</span>, box.offsetWidth)</span><br><span class=\"javascript\">      <span class=\"hljs-keyword\">if</span> (box.scrollWidth &gt; box.offsetWidth) &#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;出现了省略号&quot;</span>)</span><br><span class=\"javascript\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;没有出现省略号&quot;</span>)</span><br><span class=\"javascript\">      &#125;</span><br><span class=\"javascript\">    &#125;</span><br><span class=\"javascript\">    main()</span><br><span class=\"javascript\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<h4 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">overflow</span>:hidden;<br>    <span class=\"hljs-attribute\">text-overflow</span>:ellipsis;<br>    <span class=\"hljs-attribute\">white-space</span>:nowrap;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">display</span>: -webkit-box;<br>    -webkit-line-clamp: <span class=\"hljs-number\">2</span>;<br>    -webkit-box-orient: vertical;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\"><a href=\"#判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\" class=\"headerlink\" title=\"判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth\"></a>判断单行文本是否溢出：比较scrollWidth是否大于offsetWidth</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"javascript\">      <span class=\"hljs-keyword\">let</span> box = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;.box&#x27;</span>)</span><br><span class=\"javascript\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;scrollWidth: &quot;</span>, box.scrollWidth)</span><br><span class=\"javascript\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;offsetWidth: &quot;</span>, box.offsetWidth)</span><br><span class=\"javascript\">      <span class=\"hljs-keyword\">if</span> (box.scrollWidth &gt; box.offsetWidth) &#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;出现了省略号&quot;</span>)</span><br><span class=\"javascript\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;没有出现省略号&quot;</span>)</span><br><span class=\"javascript\">      &#125;</span><br><span class=\"javascript\">    &#125;</span><br><span class=\"javascript\">    main()</span><br><span class=\"javascript\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"dns基于tcp还是udp","date":"2021-03-11T02:39:57.000Z","excerpt":"dns基于tcp还是udp","position":null,"image_url":null,"_content":"\n### **`DNS占用53号端口，同时使用TCP和UDP协议。`**\n\n---\n\n### 1、那么DNS在什么情况下使用这两种协议？\nDNS在`区域传输`的时候使用TCP协议，其他时候使用UDP协议。\n\n### 2、区域传送时使用TCP，主要有一下两点考虑： \n1. 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 \n2. TCP是一种可靠的连接，保证了数据的准确性。 \n\n### 3、域名解析时使用UDP协议： \n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n### 4、DNS请求流程\n三种类型的 DNS 服务器，根 DNS 服务器，顶级域 DNS 服务器和权威 DNS 服务器。\n\n浏览器本地—》系统本地host文件—》路由器缓存—》运营商DNS服务器-》\n\n![image](/images/net/dns.png)\n1. 首先浏览器会检查浏览器自身的DNS缓存中，是否有域名对应的DNS缓存(chrome缓存1分钟，大概有1000条缓存)，没有的话进入第二步，否则解析完成\n1. 接下来去查看系统的hosts文件(C:\\Windows\\System32\\drivers\\etc)是否有域名对应的IP地址，如果找到则停止解析，否则进入第三步\n1. 浏览器发起DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求(通过UDP协议，向DNS的53端口发起请求)\n1. 首先请求会在运营商的**DNS服务器(本地服务器)**上进行请求，如果找到对应的条目，且没有过期，则解析成功，否则进入第五步\n1. 运营商的DNS服务器，根据解析请求，迭代查询，首先找到根域名服务器的IP地址(这个DNS服务器内置13台根域DNS的IP地址)，然后找到根域的DNS地址，发送请求\n1. 根域服务器收到请求后，根据域名，返回对应的顶级域的服务器ip地址，并返回给运营商DNS服务器\n1. 运营商DNS服务器接收到根域名服务器传回来的顶级域名服务器IP地址后，向顶级域名服务器发送请求\n1. 顶级域名服务器接收到请求后，返回该域名对应的权威域名服务器的ip地址，并返回给运行商DNS服务器。\n1. 运营商DNS服务器获得权威域名服务器的响应信息后，返回给请求的主机，DNS解析完成。\n1. DNS主要是通过UDP通信，报文结构主要分为头部Header、查询部分Question、应答部分Answer/Authority/Addition。\n","source":"_posts/dns.md","raw":"---\ntitle: dns基于tcp还是udp\ndate: 2021-03-11 10:39:57\nexcerpt: dns基于tcp还是udp\ntags: \nposition:\nimage_url:\n---\n\n### **`DNS占用53号端口，同时使用TCP和UDP协议。`**\n\n---\n\n### 1、那么DNS在什么情况下使用这两种协议？\nDNS在`区域传输`的时候使用TCP协议，其他时候使用UDP协议。\n\n### 2、区域传送时使用TCP，主要有一下两点考虑： \n1. 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 \n2. TCP是一种可靠的连接，保证了数据的准确性。 \n\n### 3、域名解析时使用UDP协议： \n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n### 4、DNS请求流程\n三种类型的 DNS 服务器，根 DNS 服务器，顶级域 DNS 服务器和权威 DNS 服务器。\n\n浏览器本地—》系统本地host文件—》路由器缓存—》运营商DNS服务器-》\n\n![image](/images/net/dns.png)\n1. 首先浏览器会检查浏览器自身的DNS缓存中，是否有域名对应的DNS缓存(chrome缓存1分钟，大概有1000条缓存)，没有的话进入第二步，否则解析完成\n1. 接下来去查看系统的hosts文件(C:\\Windows\\System32\\drivers\\etc)是否有域名对应的IP地址，如果找到则停止解析，否则进入第三步\n1. 浏览器发起DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求(通过UDP协议，向DNS的53端口发起请求)\n1. 首先请求会在运营商的**DNS服务器(本地服务器)**上进行请求，如果找到对应的条目，且没有过期，则解析成功，否则进入第五步\n1. 运营商的DNS服务器，根据解析请求，迭代查询，首先找到根域名服务器的IP地址(这个DNS服务器内置13台根域DNS的IP地址)，然后找到根域的DNS地址，发送请求\n1. 根域服务器收到请求后，根据域名，返回对应的顶级域的服务器ip地址，并返回给运营商DNS服务器\n1. 运营商DNS服务器接收到根域名服务器传回来的顶级域名服务器IP地址后，向顶级域名服务器发送请求\n1. 顶级域名服务器接收到请求后，返回该域名对应的权威域名服务器的ip地址，并返回给运行商DNS服务器。\n1. 运营商DNS服务器获得权威域名服务器的响应信息后，返回给请求的主机，DNS解析完成。\n1. DNS主要是通过UDP通信，报文结构主要分为头部Header、查询部分Question、应答部分Answer/Authority/Addition。\n","slug":"dns","published":1,"updated":"2021-05-11T02:46:37.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn1000k1kwacnffadrq","content":"<h3 id=\"DNS占用53号端口，同时使用TCP和UDP协议。\"><a href=\"#DNS占用53号端口，同时使用TCP和UDP协议。\" class=\"headerlink\" title=\"DNS占用53号端口，同时使用TCP和UDP协议。\"></a><strong><code>DNS占用53号端口，同时使用TCP和UDP协议。</code></strong></h3><hr>\n<h3 id=\"1、那么DNS在什么情况下使用这两种协议？\"><a href=\"#1、那么DNS在什么情况下使用这两种协议？\" class=\"headerlink\" title=\"1、那么DNS在什么情况下使用这两种协议？\"></a>1、那么DNS在什么情况下使用这两种协议？</h3><p>DNS在<code>区域传输</code>的时候使用TCP协议，其他时候使用UDP协议。</p>\n<h3 id=\"2、区域传送时使用TCP，主要有一下两点考虑：\"><a href=\"#2、区域传送时使用TCP，主要有一下两点考虑：\" class=\"headerlink\" title=\"2、区域传送时使用TCP，主要有一下两点考虑：\"></a>2、区域传送时使用TCP，主要有一下两点考虑：</h3><ol>\n<li>辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 </li>\n<li>TCP是一种可靠的连接，保证了数据的准确性。 </li>\n</ol>\n<h3 id=\"3、域名解析时使用UDP协议：\"><a href=\"#3、域名解析时使用UDP协议：\" class=\"headerlink\" title=\"3、域名解析时使用UDP协议：\"></a>3、域名解析时使用UDP协议：</h3><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>\n<h3 id=\"4、DNS请求流程\"><a href=\"#4、DNS请求流程\" class=\"headerlink\" title=\"4、DNS请求流程\"></a>4、DNS请求流程</h3><p>三种类型的 DNS 服务器，根 DNS 服务器，顶级域 DNS 服务器和权威 DNS 服务器。</p>\n<p>浏览器本地—》系统本地host文件—》路由器缓存—》运营商DNS服务器-》</p>\n<p><img src=\"/images/net/dns.png\" alt=\"image\"></p>\n<ol>\n<li>首先浏览器会检查浏览器自身的DNS缓存中，是否有域名对应的DNS缓存(chrome缓存1分钟，大概有1000条缓存)，没有的话进入第二步，否则解析完成</li>\n<li>接下来去查看系统的hosts文件(C:\\Windows\\System32\\drivers\\etc)是否有域名对应的IP地址，如果找到则停止解析，否则进入第三步</li>\n<li>浏览器发起DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求(通过UDP协议，向DNS的53端口发起请求)</li>\n<li>首先请求会在运营商的**DNS服务器(本地服务器)**上进行请求，如果找到对应的条目，且没有过期，则解析成功，否则进入第五步</li>\n<li>运营商的DNS服务器，根据解析请求，迭代查询，首先找到根域名服务器的IP地址(这个DNS服务器内置13台根域DNS的IP地址)，然后找到根域的DNS地址，发送请求</li>\n<li>根域服务器收到请求后，根据域名，返回对应的顶级域的服务器ip地址，并返回给运营商DNS服务器</li>\n<li>运营商DNS服务器接收到根域名服务器传回来的顶级域名服务器IP地址后，向顶级域名服务器发送请求</li>\n<li>顶级域名服务器接收到请求后，返回该域名对应的权威域名服务器的ip地址，并返回给运行商DNS服务器。</li>\n<li>运营商DNS服务器获得权威域名服务器的响应信息后，返回给请求的主机，DNS解析完成。</li>\n<li>DNS主要是通过UDP通信，报文结构主要分为头部Header、查询部分Question、应答部分Answer/Authority/Addition。</li>\n</ol>\n","site":{"data":{}},"more":"<h3 id=\"DNS占用53号端口，同时使用TCP和UDP协议。\"><a href=\"#DNS占用53号端口，同时使用TCP和UDP协议。\" class=\"headerlink\" title=\"DNS占用53号端口，同时使用TCP和UDP协议。\"></a><strong><code>DNS占用53号端口，同时使用TCP和UDP协议。</code></strong></h3><hr>\n<h3 id=\"1、那么DNS在什么情况下使用这两种协议？\"><a href=\"#1、那么DNS在什么情况下使用这两种协议？\" class=\"headerlink\" title=\"1、那么DNS在什么情况下使用这两种协议？\"></a>1、那么DNS在什么情况下使用这两种协议？</h3><p>DNS在<code>区域传输</code>的时候使用TCP协议，其他时候使用UDP协议。</p>\n<h3 id=\"2、区域传送时使用TCP，主要有一下两点考虑：\"><a href=\"#2、区域传送时使用TCP，主要有一下两点考虑：\" class=\"headerlink\" title=\"2、区域传送时使用TCP，主要有一下两点考虑：\"></a>2、区域传送时使用TCP，主要有一下两点考虑：</h3><ol>\n<li>辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 </li>\n<li>TCP是一种可靠的连接，保证了数据的准确性。 </li>\n</ol>\n<h3 id=\"3、域名解析时使用UDP协议：\"><a href=\"#3、域名解析时使用UDP协议：\" class=\"headerlink\" title=\"3、域名解析时使用UDP协议：\"></a>3、域名解析时使用UDP协议：</h3><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>\n<h3 id=\"4、DNS请求流程\"><a href=\"#4、DNS请求流程\" class=\"headerlink\" title=\"4、DNS请求流程\"></a>4、DNS请求流程</h3><p>三种类型的 DNS 服务器，根 DNS 服务器，顶级域 DNS 服务器和权威 DNS 服务器。</p>\n<p>浏览器本地—》系统本地host文件—》路由器缓存—》运营商DNS服务器-》</p>\n<p><img src=\"/images/net/dns.png\" alt=\"image\"></p>\n<ol>\n<li>首先浏览器会检查浏览器自身的DNS缓存中，是否有域名对应的DNS缓存(chrome缓存1分钟，大概有1000条缓存)，没有的话进入第二步，否则解析完成</li>\n<li>接下来去查看系统的hosts文件(C:\\Windows\\System32\\drivers\\etc)是否有域名对应的IP地址，如果找到则停止解析，否则进入第三步</li>\n<li>浏览器发起DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求(通过UDP协议，向DNS的53端口发起请求)</li>\n<li>首先请求会在运营商的**DNS服务器(本地服务器)**上进行请求，如果找到对应的条目，且没有过期，则解析成功，否则进入第五步</li>\n<li>运营商的DNS服务器，根据解析请求，迭代查询，首先找到根域名服务器的IP地址(这个DNS服务器内置13台根域DNS的IP地址)，然后找到根域的DNS地址，发送请求</li>\n<li>根域服务器收到请求后，根据域名，返回对应的顶级域的服务器ip地址，并返回给运营商DNS服务器</li>\n<li>运营商DNS服务器接收到根域名服务器传回来的顶级域名服务器IP地址后，向顶级域名服务器发送请求</li>\n<li>顶级域名服务器接收到请求后，返回该域名对应的权威域名服务器的ip地址，并返回给运行商DNS服务器。</li>\n<li>运营商DNS服务器获得权威域名服务器的响应信息后，返回给请求的主机，DNS解析完成。</li>\n<li>DNS主要是通过UDP通信，报文结构主要分为头部Header、查询部分Question、应答部分Answer/Authority/Addition。</li>\n</ol>\n"},{"title":"offsetWidth、clientWidth、scrollWidth、style.width区别","date":"2021-03-21T06:47:30.000Z","excerpt":"offsetWidth、clientWidth、scrollWidth、style.width区别","position":null,"image_url":null,"_content":"\n1. offsetWidth: contentWidth + padding + border\n1. clientWidth: contentWidth + padding\n1. scrollWidth: contentWidth + padding + 溢出区域的内容（不包含border）\n1. style.width: 需定义在html上，如果在css上，仍然为空，且获取后有单位。\n","source":"_posts/css-width.md","raw":"---\ntitle: offsetWidth、clientWidth、scrollWidth、style.width区别\ndate: 2021-03-21 14:47:30\nexcerpt: offsetWidth、clientWidth、scrollWidth、style.width区别\ntags: offsetWidth,clientWidth,scrollWidth\nposition:\nimage_url:\n---\n\n1. offsetWidth: contentWidth + padding + border\n1. clientWidth: contentWidth + padding\n1. scrollWidth: contentWidth + padding + 溢出区域的内容（不包含border）\n1. style.width: 需定义在html上，如果在css上，仍然为空，且获取后有单位。\n","slug":"css-width","published":1,"updated":"2021-05-10T06:55:01.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn2000m1kwag7lj2xft","content":"<ol>\n<li>offsetWidth: contentWidth + padding + border</li>\n<li>clientWidth: contentWidth + padding</li>\n<li>scrollWidth: contentWidth + padding + 溢出区域的内容（不包含border）</li>\n<li>style.width: 需定义在html上，如果在css上，仍然为空，且获取后有单位。</li>\n</ol>\n","site":{"data":{}},"more":"<ol>\n<li>offsetWidth: contentWidth + padding + border</li>\n<li>clientWidth: contentWidth + padding</li>\n<li>scrollWidth: contentWidth + padding + 溢出区域的内容（不包含border）</li>\n<li>style.width: 需定义在html上，如果在css上，仍然为空，且获取后有单位。</li>\n</ol>\n"},{"title":"generator","date":"2021-04-11T09:46:14.000Z","excerpt":"generator","position":null,"image_url":null,"_content":"Generator 函数\n是es6的新特性，主要配合`yield`进行**函数暂停执行**。\n```\nfunction * gen(){\n    console.log('start')\n    yield 'hello world'\n    console.log('middle')\n    yield '!!!'\n    console.log('end')\n}\n\nlet g = gen();\ng.next();//{value: 'hello world', done: false}\ng.next();//{value: '!!!', done: false}\ng.next();//{value: undefined, done: true}\n\n\n//注意，最后一个输出undefined，如果想有值，在最后加return 'over'即可。\n```\n","source":"_posts/generator.md","raw":"---\ntitle: generator\ndate: 2021-04-11 17:46:14\nexcerpt: generator\ntags: es6\nposition:\nimage_url:\n---\nGenerator 函数\n是es6的新特性，主要配合`yield`进行**函数暂停执行**。\n```\nfunction * gen(){\n    console.log('start')\n    yield 'hello world'\n    console.log('middle')\n    yield '!!!'\n    console.log('end')\n}\n\nlet g = gen();\ng.next();//{value: 'hello world', done: false}\ng.next();//{value: '!!!', done: false}\ng.next();//{value: undefined, done: true}\n\n\n//注意，最后一个输出undefined，如果想有值，在最后加return 'over'即可。\n```\n","slug":"generator","published":1,"updated":"2021-05-11T01:57:29.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn3000p1kwa2auu78nx","content":"<p>Generator 函数<br>是es6的新特性，主要配合<code>yield</code>进行<strong>函数暂停执行</strong>。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">gen</span><span class=\"hljs-params\">()</span></span>&#123;<br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;start&#x27;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;middle&#x27;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;!!!&#x27;</span><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>)<br>&#125;<br><br>let g = gen();<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: <span class=\"hljs-string\">&#x27;hello world&#x27;</span>, done: <span class=\"hljs-literal\">false</span>&#125;<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: <span class=\"hljs-string\">&#x27;!!!&#x27;</span>, done: <span class=\"hljs-literal\">false</span>&#125;<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: undefined, done: <span class=\"hljs-literal\">true</span>&#125;<br><br><br>//注意，最后一个输出undefined，如果想有值，在最后加<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;over&#x27;</span>即可。<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<p>Generator 函数<br>是es6的新特性，主要配合<code>yield</code>进行<strong>函数暂停执行</strong>。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">gen</span><span class=\"hljs-params\">()</span></span>&#123;<br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;start&#x27;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;middle&#x27;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;!!!&#x27;</span><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>)<br>&#125;<br><br>let g = gen();<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: <span class=\"hljs-string\">&#x27;hello world&#x27;</span>, done: <span class=\"hljs-literal\">false</span>&#125;<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: <span class=\"hljs-string\">&#x27;!!!&#x27;</span>, done: <span class=\"hljs-literal\">false</span>&#125;<br>g.<span class=\"hljs-built_in\">next</span>();//&#123;value: undefined, done: <span class=\"hljs-literal\">true</span>&#125;<br><br><br>//注意，最后一个输出undefined，如果想有值，在最后加<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;over&#x27;</span>即可。<br></code></pre></td></tr></table></figure>\n"},{"title":"DOM 解析和渲染","date":"2021-04-11T02:21:52.000Z","excerpt":"DOM 解析和渲染","position":null,"image_url":null,"_content":"### 一、总结：\n1. css不会阻止dom解析，但会阻止dom渲染\n2. script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。\n3. js阻塞DOM解析和渲染，但浏览器会\"偷看\"DOM，预先下载相关资源\n\n### 二、阶段含义\n阶段 | 含义\n--|--\nSend Request  |  发送http请求\nReceive Response  |  接收http返回数据                            \nParse HTML | 解析html\nParse Stylesheet | 解析css文件\nEvaluate Script | 执行js脚本\ndomContentLoadedEventEnd | dom创建完成     \nPaint | 渲染页面\nloadEventEnd | 页面加载完成\n\n### 三、常见问题\n##### 1、为何`<script>`与`<link>`同时在头部的话，`<script>`在上可能会更好？\nscript标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。\n\n\n##### 2、`<script>`最好放底部，`<link>`最好放头部。\n\n##### 3、js会阻塞DOM解析和渲染，如何优化？\n1. 如果js文件太大，同时没必要阻塞dom解析的话，可以延后加载，设置defer属性。\n2. 如果js执行时间太长，可以用异步方法。当\n\n##### 4、html的解析流程是什么\n1. 解析HTML结构。\n2. 并行加载脚本、样式表文件、img等外部资源\n3. 如有js文件未下载，则等待下载完成（js文件前如有css文件，则需要先等css文件下载完成）\n4. 脚本下载后立即执行，然后从当前解析处开始解析\n5. DOM树构建完成。//DOMContentLoaded\n6. 解析外部css文件，img图片等资源\n7. paint，渲染页面\n8. 页面加载完毕。//load\n\n\n","source":"_posts/dom-parese.md","raw":"---\ntitle: DOM 解析和渲染\ndate: 2021-04-11 10:21:52\nexcerpt: DOM 解析和渲染\ntags:\nposition:\nimage_url:\n---\n### 一、总结：\n1. css不会阻止dom解析，但会阻止dom渲染\n2. script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。\n3. js阻塞DOM解析和渲染，但浏览器会\"偷看\"DOM，预先下载相关资源\n\n### 二、阶段含义\n阶段 | 含义\n--|--\nSend Request  |  发送http请求\nReceive Response  |  接收http返回数据                            \nParse HTML | 解析html\nParse Stylesheet | 解析css文件\nEvaluate Script | 执行js脚本\ndomContentLoadedEventEnd | dom创建完成     \nPaint | 渲染页面\nloadEventEnd | 页面加载完成\n\n### 三、常见问题\n##### 1、为何`<script>`与`<link>`同时在头部的话，`<script>`在上可能会更好？\nscript标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。\n\n\n##### 2、`<script>`最好放底部，`<link>`最好放头部。\n\n##### 3、js会阻塞DOM解析和渲染，如何优化？\n1. 如果js文件太大，同时没必要阻塞dom解析的话，可以延后加载，设置defer属性。\n2. 如果js执行时间太长，可以用异步方法。当\n\n##### 4、html的解析流程是什么\n1. 解析HTML结构。\n2. 并行加载脚本、样式表文件、img等外部资源\n3. 如有js文件未下载，则等待下载完成（js文件前如有css文件，则需要先等css文件下载完成）\n4. 脚本下载后立即执行，然后从当前解析处开始解析\n5. DOM树构建完成。//DOMContentLoaded\n6. 解析外部css文件，img图片等资源\n7. paint，渲染页面\n8. 页面加载完毕。//load\n\n\n","slug":"dom-parese","published":1,"updated":"2021-05-11T02:38:20.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn5000r1kwa1dlccc2n","content":"<h3 id=\"一、总结：\"><a href=\"#一、总结：\" class=\"headerlink\" title=\"一、总结：\"></a>一、总结：</h3><ol>\n<li>css不会阻止dom解析，但会阻止dom渲染</li>\n<li>script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。</li>\n<li>js阻塞DOM解析和渲染，但浏览器会”偷看”DOM，预先下载相关资源</li>\n</ol>\n<h3 id=\"二、阶段含义\"><a href=\"#二、阶段含义\" class=\"headerlink\" title=\"二、阶段含义\"></a>二、阶段含义</h3><table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Send Request</td>\n<td>发送http请求</td>\n</tr>\n<tr>\n<td>Receive Response</td>\n<td>接收http返回数据</td>\n</tr>\n<tr>\n<td>Parse HTML</td>\n<td>解析html</td>\n</tr>\n<tr>\n<td>Parse Stylesheet</td>\n<td>解析css文件</td>\n</tr>\n<tr>\n<td>Evaluate Script</td>\n<td>执行js脚本</td>\n</tr>\n<tr>\n<td>domContentLoadedEventEnd</td>\n<td>dom创建完成</td>\n</tr>\n<tr>\n<td>Paint</td>\n<td>渲染页面</td>\n</tr>\n<tr>\n<td>loadEventEnd</td>\n<td>页面加载完成</td>\n</tr>\n</tbody></table>\n<h3 id=\"三、常见问题\"><a href=\"#三、常见问题\" class=\"headerlink\" title=\"三、常见问题\"></a>三、常见问题</h3><h5 id=\"1、为何-lt-script-gt-与-lt-link-gt-同时在头部的话，-lt-script-gt-在上可能会更好？\"><a href=\"#1、为何-lt-script-gt-与-lt-link-gt-同时在头部的话，-lt-script-gt-在上可能会更好？\" class=\"headerlink\" title=\"1、为何&lt;script&gt;与&lt;link&gt;同时在头部的话，&lt;script&gt;在上可能会更好？\"></a>1、为何<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>同时在头部的话，<code>&lt;script&gt;</code>在上可能会更好？</h5><p>script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。</p>\n<h5 id=\"2、-lt-script-gt-最好放底部，-lt-link-gt-最好放头部。\"><a href=\"#2、-lt-script-gt-最好放底部，-lt-link-gt-最好放头部。\" class=\"headerlink\" title=\"2、&lt;script&gt;最好放底部，&lt;link&gt;最好放头部。\"></a>2、<code>&lt;script&gt;</code>最好放底部，<code>&lt;link&gt;</code>最好放头部。</h5><h5 id=\"3、js会阻塞DOM解析和渲染，如何优化？\"><a href=\"#3、js会阻塞DOM解析和渲染，如何优化？\" class=\"headerlink\" title=\"3、js会阻塞DOM解析和渲染，如何优化？\"></a>3、js会阻塞DOM解析和渲染，如何优化？</h5><ol>\n<li>如果js文件太大，同时没必要阻塞dom解析的话，可以延后加载，设置defer属性。</li>\n<li>如果js执行时间太长，可以用异步方法。当</li>\n</ol>\n<h5 id=\"4、html的解析流程是什么\"><a href=\"#4、html的解析流程是什么\" class=\"headerlink\" title=\"4、html的解析流程是什么\"></a>4、html的解析流程是什么</h5><ol>\n<li>解析HTML结构。</li>\n<li>并行加载脚本、样式表文件、img等外部资源</li>\n<li>如有js文件未下载，则等待下载完成（js文件前如有css文件，则需要先等css文件下载完成）</li>\n<li>脚本下载后立即执行，然后从当前解析处开始解析</li>\n<li>DOM树构建完成。//DOMContentLoaded</li>\n<li>解析外部css文件，img图片等资源</li>\n<li>paint，渲染页面</li>\n<li>页面加载完毕。//load</li>\n</ol>\n","site":{"data":{}},"more":"<h3 id=\"一、总结：\"><a href=\"#一、总结：\" class=\"headerlink\" title=\"一、总结：\"></a>一、总结：</h3><ol>\n<li>css不会阻止dom解析，但会阻止dom渲染</li>\n<li>script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。</li>\n<li>js阻塞DOM解析和渲染，但浏览器会”偷看”DOM，预先下载相关资源</li>\n</ol>\n<h3 id=\"二、阶段含义\"><a href=\"#二、阶段含义\" class=\"headerlink\" title=\"二、阶段含义\"></a>二、阶段含义</h3><table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Send Request</td>\n<td>发送http请求</td>\n</tr>\n<tr>\n<td>Receive Response</td>\n<td>接收http返回数据</td>\n</tr>\n<tr>\n<td>Parse HTML</td>\n<td>解析html</td>\n</tr>\n<tr>\n<td>Parse Stylesheet</td>\n<td>解析css文件</td>\n</tr>\n<tr>\n<td>Evaluate Script</td>\n<td>执行js脚本</td>\n</tr>\n<tr>\n<td>domContentLoadedEventEnd</td>\n<td>dom创建完成</td>\n</tr>\n<tr>\n<td>Paint</td>\n<td>渲染页面</td>\n</tr>\n<tr>\n<td>loadEventEnd</td>\n<td>页面加载完成</td>\n</tr>\n</tbody></table>\n<h3 id=\"三、常见问题\"><a href=\"#三、常见问题\" class=\"headerlink\" title=\"三、常见问题\"></a>三、常见问题</h3><h5 id=\"1、为何-lt-script-gt-与-lt-link-gt-同时在头部的话，-lt-script-gt-在上可能会更好？\"><a href=\"#1、为何-lt-script-gt-与-lt-link-gt-同时在头部的话，-lt-script-gt-在上可能会更好？\" class=\"headerlink\" title=\"1、为何&lt;script&gt;与&lt;link&gt;同时在头部的话，&lt;script&gt;在上可能会更好？\"></a>1、为何<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>同时在头部的话，<code>&lt;script&gt;</code>在上可能会更好？</h5><p>script标签要等前面外联的css下载完成后，再去执行。如果link的css文件太大，则没必要等待。</p>\n<h5 id=\"2、-lt-script-gt-最好放底部，-lt-link-gt-最好放头部。\"><a href=\"#2、-lt-script-gt-最好放底部，-lt-link-gt-最好放头部。\" class=\"headerlink\" title=\"2、&lt;script&gt;最好放底部，&lt;link&gt;最好放头部。\"></a>2、<code>&lt;script&gt;</code>最好放底部，<code>&lt;link&gt;</code>最好放头部。</h5><h5 id=\"3、js会阻塞DOM解析和渲染，如何优化？\"><a href=\"#3、js会阻塞DOM解析和渲染，如何优化？\" class=\"headerlink\" title=\"3、js会阻塞DOM解析和渲染，如何优化？\"></a>3、js会阻塞DOM解析和渲染，如何优化？</h5><ol>\n<li>如果js文件太大，同时没必要阻塞dom解析的话，可以延后加载，设置defer属性。</li>\n<li>如果js执行时间太长，可以用异步方法。当</li>\n</ol>\n<h5 id=\"4、html的解析流程是什么\"><a href=\"#4、html的解析流程是什么\" class=\"headerlink\" title=\"4、html的解析流程是什么\"></a>4、html的解析流程是什么</h5><ol>\n<li>解析HTML结构。</li>\n<li>并行加载脚本、样式表文件、img等外部资源</li>\n<li>如有js文件未下载，则等待下载完成（js文件前如有css文件，则需要先等css文件下载完成）</li>\n<li>脚本下载后立即执行，然后从当前解析处开始解析</li>\n<li>DOM树构建完成。//DOMContentLoaded</li>\n<li>解析外部css文件，img图片等资源</li>\n<li>paint，渲染页面</li>\n<li>页面加载完毕。//load</li>\n</ol>\n"},{"title":"happyPack多线程打包","date":"2021-03-25T09:28:21.000Z","_content":"##### 1、安装happypack\n```\n    npm i happypack\n```\n\n##### 2、实现js和css的多线程打包\n```\nlet HappyPack = require('happypack');\n\nmodule.exports = {\n    ...\n    module:{\n        rules:[\n            {\n                test:/\\.js$/,\n                use:'HappyPack/loader?id=js'//这个id=js就代表这是打包js的\n            },\n            {\n                test:/\\.css$/,\n                use:'HappyPack/loader?id=css'//这个id=css就代表这是打包css的\n            }\n        ]\n    },\n    plugins:[\n        new HappyPack({这个id:js就代表这是打包js的\n            id:'css',//\n            use:['style-loader','css-loader']\n        }),\n        new HappyPack({这个id:js就代表这是打包js的\n            id:'js',//\n            use:[{//use是一个数组，这里写原先在rules的use里的loader配置\n                loader:'babel-loader',\n                options:{\n                    presets:[\n                        '@babel/presets-env',\n                        '@babel/presets-react'\n                    ]\n                }\n            }]\n        })\n    ]\n}\n```\n\n","source":"_posts/happyPack.md","raw":"---\ntitle: happyPack多线程打包\ndate: 2021-03-25 17:28:21\ntags:\n---\n##### 1、安装happypack\n```\n    npm i happypack\n```\n\n##### 2、实现js和css的多线程打包\n```\nlet HappyPack = require('happypack');\n\nmodule.exports = {\n    ...\n    module:{\n        rules:[\n            {\n                test:/\\.js$/,\n                use:'HappyPack/loader?id=js'//这个id=js就代表这是打包js的\n            },\n            {\n                test:/\\.css$/,\n                use:'HappyPack/loader?id=css'//这个id=css就代表这是打包css的\n            }\n        ]\n    },\n    plugins:[\n        new HappyPack({这个id:js就代表这是打包js的\n            id:'css',//\n            use:['style-loader','css-loader']\n        }),\n        new HappyPack({这个id:js就代表这是打包js的\n            id:'js',//\n            use:[{//use是一个数组，这里写原先在rules的use里的loader配置\n                loader:'babel-loader',\n                options:{\n                    presets:[\n                        '@babel/presets-env',\n                        '@babel/presets-react'\n                    ]\n                }\n            }]\n        })\n    ]\n}\n```\n\n","slug":"happyPack","published":1,"updated":"2021-05-08T09:35:55.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn6000t1kwagmhk19lq","content":"<h5 id=\"1、安装happypack\"><a href=\"#1、安装happypack\" class=\"headerlink\" title=\"1、安装happypack\"></a>1、安装happypack</h5><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> i happypack<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2、实现js和css的多线程打包\"><a href=\"#2、实现js和css的多线程打包\" class=\"headerlink\" title=\"2、实现js和css的多线程打包\"></a>2、实现js和css的多线程打包</h5><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">let HappyPack = require(<span class=\"hljs-string\">&#x27;happypack&#x27;</span>);<br><br>module.exports = &#123;<br>    ...<br>    module:&#123;<br>        rules:[<br>            &#123;<br>                test:<span class=\"hljs-regexp\">/\\.js$/</span>,<br>                use:<span class=\"hljs-string\">&#x27;HappyPack/loader?id=js&#x27;</span><span class=\"hljs-regexp\">//</span>这个id=js就代表这是打包js的<br>            &#125;,<br>            &#123;<br>                test:<span class=\"hljs-regexp\">/\\.css$/</span>,<br>                use:<span class=\"hljs-string\">&#x27;HappyPack/loader?id=css&#x27;</span><span class=\"hljs-regexp\">//</span>这个id=css就代表这是打包css的<br>            &#125;<br>        ]<br>    &#125;,<br>    plugins:[<br>        new HappyPack(&#123;这个id:js就代表这是打包js的<br>            id:<span class=\"hljs-string\">&#x27;css&#x27;</span>,<span class=\"hljs-regexp\">//</span><br>            use:[<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>,<span class=\"hljs-string\">&#x27;css-loader&#x27;</span>]<br>        &#125;),<br>        new HappyPack(&#123;这个id:js就代表这是打包js的<br>            id:<span class=\"hljs-string\">&#x27;js&#x27;</span>,<span class=\"hljs-regexp\">//</span><br>            use:[&#123;<span class=\"hljs-regexp\">//u</span>se是一个数组，这里写原先在rules的use里的loader配置<br>                loader:<span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,<br>                options:&#123;<br>                    presets:[<br>                        <span class=\"hljs-string\">&#x27;@babel/presets-env&#x27;</span>,<br>                        <span class=\"hljs-string\">&#x27;@babel/presets-react&#x27;</span><br>                    ]<br>                &#125;<br>            &#125;]<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1、安装happypack\"><a href=\"#1、安装happypack\" class=\"headerlink\" title=\"1、安装happypack\"></a>1、安装happypack</h5><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> i happypack<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2、实现js和css的多线程打包\"><a href=\"#2、实现js和css的多线程打包\" class=\"headerlink\" title=\"2、实现js和css的多线程打包\"></a>2、实现js和css的多线程打包</h5><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">let HappyPack = require(<span class=\"hljs-string\">&#x27;happypack&#x27;</span>);<br><br>module.exports = &#123;<br>    ...<br>    module:&#123;<br>        rules:[<br>            &#123;<br>                test:<span class=\"hljs-regexp\">/\\.js$/</span>,<br>                use:<span class=\"hljs-string\">&#x27;HappyPack/loader?id=js&#x27;</span><span class=\"hljs-regexp\">//</span>这个id=js就代表这是打包js的<br>            &#125;,<br>            &#123;<br>                test:<span class=\"hljs-regexp\">/\\.css$/</span>,<br>                use:<span class=\"hljs-string\">&#x27;HappyPack/loader?id=css&#x27;</span><span class=\"hljs-regexp\">//</span>这个id=css就代表这是打包css的<br>            &#125;<br>        ]<br>    &#125;,<br>    plugins:[<br>        new HappyPack(&#123;这个id:js就代表这是打包js的<br>            id:<span class=\"hljs-string\">&#x27;css&#x27;</span>,<span class=\"hljs-regexp\">//</span><br>            use:[<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>,<span class=\"hljs-string\">&#x27;css-loader&#x27;</span>]<br>        &#125;),<br>        new HappyPack(&#123;这个id:js就代表这是打包js的<br>            id:<span class=\"hljs-string\">&#x27;js&#x27;</span>,<span class=\"hljs-regexp\">//</span><br>            use:[&#123;<span class=\"hljs-regexp\">//u</span>se是一个数组，这里写原先在rules的use里的loader配置<br>                loader:<span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,<br>                options:&#123;<br>                    presets:[<br>                        <span class=\"hljs-string\">&#x27;@babel/presets-env&#x27;</span>,<br>                        <span class=\"hljs-string\">&#x27;@babel/presets-react&#x27;</span><br>                    ]<br>                &#125;<br>            &#125;]<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"jwt token","date":"2020-12-09T09:06:43.000Z","excerpt":"jwt","position":null,"image_url":null,"_content":"##### jwt token主要包含以下三个内容：\n- 头部 Header      Base64URL加密\n- 载荷 Payload     Base64URL加密\n- 签名 Signature    \n\n```\n{Header 头部}.{Payload 负载}.{Signature 签名}\n\n签名计算方法：\nHMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)\n```\n","source":"_posts/jwt.md","raw":"---\ntitle: jwt token\ndate: 2020-12-09 17:06:43\nexcerpt: jwt\ntags:\nposition:\nimage_url:\n---\n##### jwt token主要包含以下三个内容：\n- 头部 Header      Base64URL加密\n- 载荷 Payload     Base64URL加密\n- 签名 Signature    \n\n```\n{Header 头部}.{Payload 负载}.{Signature 签名}\n\n签名计算方法：\nHMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)\n```\n","slug":"jwt","published":1,"updated":"2021-05-10T09:08:53.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn7000v1kwaa3171zov","content":"<h5 id=\"jwt-token主要包含以下三个内容：\"><a href=\"#jwt-token主要包含以下三个内容：\" class=\"headerlink\" title=\"jwt token主要包含以下三个内容：\"></a>jwt token主要包含以下三个内容：</h5><ul>\n<li>头部 Header      Base64URL加密</li>\n<li>载荷 Payload     Base64URL加密</li>\n<li>签名 Signature    </li>\n</ul>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">&#123;Header 头部&#125;.&#123;Payload 负载&#125;.&#123;Signature 签名&#125;<br><br>签名计算方法：<br><span class=\"hljs-constructor\">HMACSHA256(<span class=\"hljs-params\">base64UrlEncode</span>(<span class=\"hljs-params\">header</span>)</span> + <span class=\"hljs-string\">&quot;.&quot;</span> + base64<span class=\"hljs-constructor\">UrlEncode(<span class=\"hljs-params\">payload</span>)</span>, secret)<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<h5 id=\"jwt-token主要包含以下三个内容：\"><a href=\"#jwt-token主要包含以下三个内容：\" class=\"headerlink\" title=\"jwt token主要包含以下三个内容：\"></a>jwt token主要包含以下三个内容：</h5><ul>\n<li>头部 Header      Base64URL加密</li>\n<li>载荷 Payload     Base64URL加密</li>\n<li>签名 Signature    </li>\n</ul>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">&#123;Header 头部&#125;.&#123;Payload 负载&#125;.&#123;Signature 签名&#125;<br><br>签名计算方法：<br><span class=\"hljs-constructor\">HMACSHA256(<span class=\"hljs-params\">base64UrlEncode</span>(<span class=\"hljs-params\">header</span>)</span> + <span class=\"hljs-string\">&quot;.&quot;</span> + base64<span class=\"hljs-constructor\">UrlEncode(<span class=\"hljs-params\">payload</span>)</span>, secret)<br></code></pre></td></tr></table></figure>\n"},{"title":"消除浏览器对input输入框的自动填充","date":"2019-05-07T07:42:27.000Z","excerpt":"消除浏览器对input输入框的自动填充","position":null,"image_url":null,"_content":"> 参考url：https://www.cnblogs.com/mamimi/p/9138555.html\n> \nMozilla官方文档建议的是 直接使用 autocomplete = ‘off’ 即可禁止输入框从浏览器cache获取数据，博主以前使用这个也就足够兼容浏览器了。\n\n现在发现，却在chrome、firfox上有兼容性 无法解决。\n\n后来查阅相关资料得到以下解决方法：\n\n**1：可以设置一个默认的input用来接收浏览器的默认填充，并且设置css为dispaly：none\n形如：**\n\n```\n<input type = 'text' style='display:none'>\n```\n\n这样既不会影响用户的体验，也可以兼容所有的浏览器，但经过测试却发现，在chrome上不起作用，在firefox上也只能对type != password的 输入框起作用。\n\n**2：autocomplete = 'new-password'**\n```\n<input type='text' >\n<input type='password' autocomplete='new-password' >\n```\n\n使用上诉代码，在chrome上既可生效，用户名与密码都不会自动填充，但是firefox上任然会自动填充用户名\n\n**3：结合上诉两个情况\n<input type='text' style='display:none'>**\n```\n<!-- 针对firefox -->\n用户名：<input type='text' autocomplete='off'> \n密码：<input type='password' autocomplete='new-password'>\n```\n既可解决针对chrome与firefox内核的浏览器自动填充输入框的问题\n\n**4：但是近期经过测试发现 这种方法还是不能解决firefox上密码框的历史输入，可以在3步骤上做这样的操作：**\n\n```\n\n<input type='password' autocomplete=\"new-password\"\n       style=\"background-color: #FFFFFF!important;\"\n       readonly onfocus=\"this.removeAttribute('readonly');\"\n       onblur=\"this.setAttribute('readonly',true);\"/>\n```\n\n\n","source":"_posts/input-autocomplete.md","raw":"---\ntitle: 消除浏览器对input输入框的自动填充\ndate: 2019-05-07 15:42:27\nexcerpt: 消除浏览器对input输入框的自动填充\ntags:\nposition:\nimage_url:\n---\n> 参考url：https://www.cnblogs.com/mamimi/p/9138555.html\n> \nMozilla官方文档建议的是 直接使用 autocomplete = ‘off’ 即可禁止输入框从浏览器cache获取数据，博主以前使用这个也就足够兼容浏览器了。\n\n现在发现，却在chrome、firfox上有兼容性 无法解决。\n\n后来查阅相关资料得到以下解决方法：\n\n**1：可以设置一个默认的input用来接收浏览器的默认填充，并且设置css为dispaly：none\n形如：**\n\n```\n<input type = 'text' style='display:none'>\n```\n\n这样既不会影响用户的体验，也可以兼容所有的浏览器，但经过测试却发现，在chrome上不起作用，在firefox上也只能对type != password的 输入框起作用。\n\n**2：autocomplete = 'new-password'**\n```\n<input type='text' >\n<input type='password' autocomplete='new-password' >\n```\n\n使用上诉代码，在chrome上既可生效，用户名与密码都不会自动填充，但是firefox上任然会自动填充用户名\n\n**3：结合上诉两个情况\n<input type='text' style='display:none'>**\n```\n<!-- 针对firefox -->\n用户名：<input type='text' autocomplete='off'> \n密码：<input type='password' autocomplete='new-password'>\n```\n既可解决针对chrome与firefox内核的浏览器自动填充输入框的问题\n\n**4：但是近期经过测试发现 这种方法还是不能解决firefox上密码框的历史输入，可以在3步骤上做这样的操作：**\n\n```\n\n<input type='password' autocomplete=\"new-password\"\n       style=\"background-color: #FFFFFF!important;\"\n       readonly onfocus=\"this.removeAttribute('readonly');\"\n       onblur=\"this.setAttribute('readonly',true);\"/>\n```\n\n\n","slug":"input-autocomplete","published":1,"updated":"2021-05-10T07:50:02.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkn9000x1kwa4s748qjh","content":"<blockquote>\n<p>参考url：<a href=\"https://www.cnblogs.com/mamimi/p/9138555.html\">https://www.cnblogs.com/mamimi/p/9138555.html</a></p>\n</blockquote>\n<p>Mozilla官方文档建议的是 直接使用 autocomplete = ‘off’ 即可禁止输入框从浏览器cache获取数据，博主以前使用这个也就足够兼容浏览器了。</p>\n<p>现在发现，却在chrome、firfox上有兼容性 无法解决。</p>\n<p>后来查阅相关资料得到以下解决方法：</p>\n<p><strong>1：可以设置一个默认的input用来接收浏览器的默认填充，并且设置css为dispaly：none<br>形如：</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&lt;input<span class=\"hljs-built_in\"> type </span>= <span class=\"hljs-string\">&#x27;text&#x27;</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-string\">&#x27;display:none&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这样既不会影响用户的体验，也可以兼容所有的浏览器，但经过测试却发现，在chrome上不起作用，在firefox上也只能对type != password的 输入框起作用。</p>\n<p><strong>2：autocomplete = ‘new-password’</strong></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">&lt;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&#x27;text&#x27;</span> &gt;<br>&lt;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> autocomplete=<span class=\"hljs-string\">&#x27;new-password&#x27;</span> &gt;<br></code></pre></td></tr></table></figure>\n\n<p>使用上诉代码，在chrome上既可生效，用户名与密码都不会自动填充，但是firefox上任然会自动填充用户名</p>\n<p><strong>3：结合上诉两个情况<br><input type='text' style='display:none'></strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!-- 针对firefox --&gt;</span><br>用户名：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&#x27;text&#x27;</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#x27;off&#x27;</span>&gt;</span> <br>密码：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#x27;new-password&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既可解决针对chrome与firefox内核的浏览器自动填充输入框的问题</p>\n<p><strong>4：但是近期经过测试发现 这种方法还是不能解决firefox上密码框的历史输入，可以在3步骤上做这样的操作：</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><br>&lt;input <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> <span class=\"hljs-attribute\">autocomplete</span>=<span class=\"hljs-string\">&quot;new-password&quot;</span><br>       <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-string\">&quot;background-color: #FFFFFF!important;&quot;</span><br>       readonly <span class=\"hljs-attribute\">onfocus</span>=<span class=\"hljs-string\">&quot;this.removeAttribute(&#x27;readonly&#x27;);&quot;</span><br>       <span class=\"hljs-attribute\">onblur</span>=<span class=\"hljs-string\">&quot;this.setAttribute(&#x27;readonly&#x27;,true);&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"more":"<blockquote>\n<p>参考url：<a href=\"https://www.cnblogs.com/mamimi/p/9138555.html\">https://www.cnblogs.com/mamimi/p/9138555.html</a></p>\n</blockquote>\n<p>Mozilla官方文档建议的是 直接使用 autocomplete = ‘off’ 即可禁止输入框从浏览器cache获取数据，博主以前使用这个也就足够兼容浏览器了。</p>\n<p>现在发现，却在chrome、firfox上有兼容性 无法解决。</p>\n<p>后来查阅相关资料得到以下解决方法：</p>\n<p><strong>1：可以设置一个默认的input用来接收浏览器的默认填充，并且设置css为dispaly：none<br>形如：</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&lt;input<span class=\"hljs-built_in\"> type </span>= <span class=\"hljs-string\">&#x27;text&#x27;</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-string\">&#x27;display:none&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这样既不会影响用户的体验，也可以兼容所有的浏览器，但经过测试却发现，在chrome上不起作用，在firefox上也只能对type != password的 输入框起作用。</p>\n<p><strong>2：autocomplete = ‘new-password’</strong></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">&lt;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&#x27;text&#x27;</span> &gt;<br>&lt;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> autocomplete=<span class=\"hljs-string\">&#x27;new-password&#x27;</span> &gt;<br></code></pre></td></tr></table></figure>\n\n<p>使用上诉代码，在chrome上既可生效，用户名与密码都不会自动填充，但是firefox上任然会自动填充用户名</p>\n<p><strong>3：结合上诉两个情况<br><input type='text' style='display:none'></strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!-- 针对firefox --&gt;</span><br>用户名：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&#x27;text&#x27;</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#x27;off&#x27;</span>&gt;</span> <br>密码：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#x27;new-password&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既可解决针对chrome与firefox内核的浏览器自动填充输入框的问题</p>\n<p><strong>4：但是近期经过测试发现 这种方法还是不能解决firefox上密码框的历史输入，可以在3步骤上做这样的操作：</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><br>&lt;input <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-string\">&#x27;password&#x27;</span> <span class=\"hljs-attribute\">autocomplete</span>=<span class=\"hljs-string\">&quot;new-password&quot;</span><br>       <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-string\">&quot;background-color: #FFFFFF!important;&quot;</span><br>       readonly <span class=\"hljs-attribute\">onfocus</span>=<span class=\"hljs-string\">&quot;this.removeAttribute(&#x27;readonly&#x27;);&quot;</span><br>       <span class=\"hljs-attribute\">onblur</span>=<span class=\"hljs-string\">&quot;this.setAttribute(&#x27;readonly&#x27;,true);&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"linux命令—老记混系列","date":"2020-11-24T01:59:11.000Z","excerpt":"常用的linux命令","position":1,"image_url":null,"_content":"\n```\n查看当前进程的线程数量\n# pstree -p 进程号 | wc -l\n\n查看文件夹下文件数量\n# ls | wc -w\n\n查看磁盘占用：\n# df -h\n\n查看内存占用\n# free -m\n\n查看端口占用\n# netstat -anp | grep 端口号\n\n查看全部端口占用\n# netstat -nultp\n\n查看机器是固态还是机械\n# lsblk -d -o name,rota\n对于其返回值，看rota值来判断，如果rota为1，则意味旋转，则为机械盘，若rota为0则意味着发该盘为固态\n\n查看硬盘信息\n# fdisk -l\n# hdparm -i /dev/sda1\n# hdparm -i /dev/sdb1 |grep -i serialno\nSerialNo=Z1Z0MKWS 硬盘序列号\n\nvim中查询计数（例：查yes）\n# :%s/yes//gn\n\n查看某个进程的线程数\n# pstree -p 进程id | wc -l\n\n远程复制\n# scp -r flume/ hadoop@hadoop03:$PWD\n\n查看cpu个数\n# lscpu\n \n每个cpu的核数\n#cat /proc/cpuinfo | grep \"cpu cores\" | uniq\n \n查看内存总数\n#cat /proc/meminfo | grep MemTotal\n\n修改拥有者（chown）\n# chown hadoop:hadoop rootfs\n\n修改权限（chmod ）\n  文字设定法\n# chmod [who] [+ | - | =] [mode] 文件名\n  eg: chmod g+r，o+r example\n    who：\n      u 表示“用户（user）”，即文件或目录的所有者。\n      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。\n      o 表示“其他（others）用户”。\n      a 表示“所有（all）用户”。它是系统默认值。\n    操作符：\n      + 添加某个权限。\n      - 取消某个权限。\n      = 赋予给定权限并取消其他所有权限（如果有的话）。\n    mode：\n      r 可读。\n      w 可写。\n      x 可执行。\n      X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。\n      s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。\n      t 保存程序的文本到交换设备上。\n      u 与文件属主拥有一样的权限。\n      g 与和文件属主同组的用户拥有一样的权限。\n      o 与其他用户拥有一样的权限。\n  数字设定法\n# chmod [mode] 文件名\n0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。\n\n\n[viewer@ tomcat]$ ll\ntotal 160\n-rw-r----- 1 root root  7142 Dec 12  2018 RELEASE-NOTES\n-rw-r----- 1 root root 16262 Dec 12  2018 RUNNING.txt\ndrwxr-x--- 2 root root  4096 Feb 27 13:34 temp\ndrwxr-x--- 4 root root  4096 Apr 19 13:36 webapps\ndrwxr-x--- 3 root root  4096 Feb 27 13:35 work\n\n#清除cache\necho 1 > /proc/sys/vm/drop_caches:表示清除pagecache。\necho 2 > /proc/sys/vm/drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。\necho 3 > /proc/sys/vm/drop_caches:表示清除pagecache和slab分配器中的缓存对象。\n\n从本地复制到远程\n# 拷贝文件\nscp /home/test/test.txt root@192.168.0.2:/home/test/\n# 拷贝目录\nscp -r /home/test/ root@192.168.0.2:/home/test/\n\n从远程复制到本地\n# 拷贝文件\nscp root@192.168.0.2:/home/test/ /home/test/test.txt\n# 拷贝目录\nscp -r root@192.168.0.2:/home/test/ v/home/test/\n\n# 压缩解压\n压缩：\ntar -zcvf /home/xahot.tar.gz /xahot\nzip -r ./xahot.zip ./* -r\n\n\n解压：\ntar –xvf file.tar //解压 tar包\ntar -xzvf file.tar.gz //解压tar.gz\ntar -xjvf file.tar.bz2   //解压 tar.bz2\ntar –xZvf file.tar.Z   //解压tar.Z\nunrar e file.rar //解压rar\nunzip file.zip //解压zip\n```\n","source":"_posts/linux01.md","raw":"---\ntitle: linux命令—老记混系列\ndate: 2020-11-24 09:59:11\nexcerpt: 常用的linux命令\ntags: linux\nposition: 1\nimage_url:\n---\n\n```\n查看当前进程的线程数量\n# pstree -p 进程号 | wc -l\n\n查看文件夹下文件数量\n# ls | wc -w\n\n查看磁盘占用：\n# df -h\n\n查看内存占用\n# free -m\n\n查看端口占用\n# netstat -anp | grep 端口号\n\n查看全部端口占用\n# netstat -nultp\n\n查看机器是固态还是机械\n# lsblk -d -o name,rota\n对于其返回值，看rota值来判断，如果rota为1，则意味旋转，则为机械盘，若rota为0则意味着发该盘为固态\n\n查看硬盘信息\n# fdisk -l\n# hdparm -i /dev/sda1\n# hdparm -i /dev/sdb1 |grep -i serialno\nSerialNo=Z1Z0MKWS 硬盘序列号\n\nvim中查询计数（例：查yes）\n# :%s/yes//gn\n\n查看某个进程的线程数\n# pstree -p 进程id | wc -l\n\n远程复制\n# scp -r flume/ hadoop@hadoop03:$PWD\n\n查看cpu个数\n# lscpu\n \n每个cpu的核数\n#cat /proc/cpuinfo | grep \"cpu cores\" | uniq\n \n查看内存总数\n#cat /proc/meminfo | grep MemTotal\n\n修改拥有者（chown）\n# chown hadoop:hadoop rootfs\n\n修改权限（chmod ）\n  文字设定法\n# chmod [who] [+ | - | =] [mode] 文件名\n  eg: chmod g+r，o+r example\n    who：\n      u 表示“用户（user）”，即文件或目录的所有者。\n      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。\n      o 表示“其他（others）用户”。\n      a 表示“所有（all）用户”。它是系统默认值。\n    操作符：\n      + 添加某个权限。\n      - 取消某个权限。\n      = 赋予给定权限并取消其他所有权限（如果有的话）。\n    mode：\n      r 可读。\n      w 可写。\n      x 可执行。\n      X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。\n      s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。\n      t 保存程序的文本到交换设备上。\n      u 与文件属主拥有一样的权限。\n      g 与和文件属主同组的用户拥有一样的权限。\n      o 与其他用户拥有一样的权限。\n  数字设定法\n# chmod [mode] 文件名\n0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。\n\n\n[viewer@ tomcat]$ ll\ntotal 160\n-rw-r----- 1 root root  7142 Dec 12  2018 RELEASE-NOTES\n-rw-r----- 1 root root 16262 Dec 12  2018 RUNNING.txt\ndrwxr-x--- 2 root root  4096 Feb 27 13:34 temp\ndrwxr-x--- 4 root root  4096 Apr 19 13:36 webapps\ndrwxr-x--- 3 root root  4096 Feb 27 13:35 work\n\n#清除cache\necho 1 > /proc/sys/vm/drop_caches:表示清除pagecache。\necho 2 > /proc/sys/vm/drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。\necho 3 > /proc/sys/vm/drop_caches:表示清除pagecache和slab分配器中的缓存对象。\n\n从本地复制到远程\n# 拷贝文件\nscp /home/test/test.txt root@192.168.0.2:/home/test/\n# 拷贝目录\nscp -r /home/test/ root@192.168.0.2:/home/test/\n\n从远程复制到本地\n# 拷贝文件\nscp root@192.168.0.2:/home/test/ /home/test/test.txt\n# 拷贝目录\nscp -r root@192.168.0.2:/home/test/ v/home/test/\n\n# 压缩解压\n压缩：\ntar -zcvf /home/xahot.tar.gz /xahot\nzip -r ./xahot.zip ./* -r\n\n\n解压：\ntar –xvf file.tar //解压 tar包\ntar -xzvf file.tar.gz //解压tar.gz\ntar -xjvf file.tar.bz2   //解压 tar.bz2\ntar –xZvf file.tar.Z   //解压tar.Z\nunrar e file.rar //解压rar\nunzip file.zip //解压zip\n```\n","slug":"linux01","published":1,"updated":"2021-05-08T09:45:19.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkna000z1kwabfit8pol","content":"<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">查看当前进程的线程数量<br><span class=\"hljs-comment\"># pstree -p 进程号 | wc -l</span><br><br>查看文件夹下文件数量<br><span class=\"hljs-comment\"># ls | wc -w</span><br><br>查看磁盘占用：<br><span class=\"hljs-comment\"># df -h</span><br><br>查看内存占用<br><span class=\"hljs-comment\"># free -m</span><br><br>查看端口占用<br><span class=\"hljs-comment\"># netstat -anp | grep 端口号</span><br><br>查看全部端口占用<br><span class=\"hljs-comment\"># netstat -nultp</span><br><br>查看机器是固态还是机械<br><span class=\"hljs-comment\"># lsblk -d -o name,rota</span><br>对于其返回值，看rota值来判断，如果rota为<span class=\"hljs-number\">1</span>，则意味旋转，则为机械盘，若rota为<span class=\"hljs-number\">0</span>则意味着发该盘为固态<br><br>查看硬盘信息<br><span class=\"hljs-comment\"># fdisk -l</span><br><span class=\"hljs-comment\"># hdparm -i /dev/sda1</span><br><span class=\"hljs-comment\"># hdparm -i /dev/sdb1 |grep -i serialno</span><br>SerialNo=Z1Z0MKWS 硬盘序列号<br><br>vim中查询计数（例：查yes）<br><span class=\"hljs-comment\"># :%s/yes//gn</span><br><br>查看某个进程的线程数<br><span class=\"hljs-comment\"># pstree -p 进程id | wc -l</span><br><br>远程复制<br><span class=\"hljs-comment\"># scp -r flume/ hadoop@hadoop03:$PWD</span><br><br>查看cpu个数<br><span class=\"hljs-comment\"># lscpu</span><br> <br>每个cpu的核数<br><span class=\"hljs-comment\">#cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</span><br> <br>查看内存总数<br><span class=\"hljs-comment\">#cat /proc/meminfo | grep MemTotal</span><br><br>修改拥有者（chown）<br><span class=\"hljs-comment\"># chown hadoop:hadoop rootfs</span><br><br>修改权限（chmod ）<br>  文字设定法<br><span class=\"hljs-comment\"># chmod [who] [+ | - | =] [mode] 文件名</span><br>  eg: chmod g+r，o+r example<br>    who：<br>      u 表示“用户（user）”，即文件或目录的所有者。<br>      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>      o 表示“其他（others）用户”。<br>      a 表示“所有（all）用户”。它是系统默认值。<br>    操作符：<br>      + 添加某个权限。<br>      - 取消某个权限。<br>      = 赋予给定权限并取消其他所有权限（如果有的话）。<br>    mode：<br>      r 可读。<br>      w 可写。<br>      x 可执行。<br>      X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。<br>      s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。<br>      t 保存程序的文本到交换设备上。<br>      u 与文件属主拥有一样的权限。<br>      g 与和文件属主同组的用户拥有一样的权限。<br>      o 与其他用户拥有一样的权限。<br>  数字设定法<br><span class=\"hljs-comment\"># chmod [mode] 文件名</span><br><span class=\"hljs-number\">0</span>表示没有权限，<span class=\"hljs-number\">1</span>表示可执行权限，<span class=\"hljs-number\">2</span>表示可写权限，<span class=\"hljs-number\">4</span>表示可读权限，然后将其相加。<br><br><br>[viewer@ tomcat]$ ll<br>total <span class=\"hljs-number\">160</span><br>-rw-r----- <span class=\"hljs-number\">1</span> root root  <span class=\"hljs-number\">7142</span> Dec <span class=\"hljs-number\">12</span>  <span class=\"hljs-number\">2018</span> RELEASE-NOTES<br>-rw-r----- <span class=\"hljs-number\">1</span> root root <span class=\"hljs-number\">16262</span> Dec <span class=\"hljs-number\">12</span>  <span class=\"hljs-number\">2018</span> RUNNING.txt<br>drwxr-x--- <span class=\"hljs-number\">2</span> root root  <span class=\"hljs-number\">4096</span> Feb <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">34</span> temp<br>drwxr-x--- <span class=\"hljs-number\">4</span> root root  <span class=\"hljs-number\">4096</span> Apr <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">36</span> webapps<br>drwxr-x--- <span class=\"hljs-number\">3</span> root root  <span class=\"hljs-number\">4096</span> Feb <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">35</span> work<br><br><span class=\"hljs-comment\">#清除cache</span><br>echo <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除pagecache。<br>echo <span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。<br>echo <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除pagecache和slab分配器中的缓存对象。<br><br>从本地复制到远程<br><span class=\"hljs-comment\"># 拷贝文件</span><br>scp <span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/test.txt root@192.168.0.2:/</span>home<span class=\"hljs-regexp\">/test/</span><br><span class=\"hljs-comment\"># 拷贝目录</span><br>scp -r <span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ root@192.168.0.2:/</span>home<span class=\"hljs-regexp\">/test/</span><br><br>从远程复制到本地<br><span class=\"hljs-comment\"># 拷贝文件</span><br>scp root@<span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">0.2</span>:<span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ /</span>home<span class=\"hljs-regexp\">/test/</span>test.txt<br><span class=\"hljs-comment\"># 拷贝目录</span><br>scp -r root@<span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">0.2</span>:<span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ v/</span>home<span class=\"hljs-regexp\">/test/</span><br><br><span class=\"hljs-comment\"># 压缩解压</span><br>压缩：<br>tar -zcvf <span class=\"hljs-regexp\">/home/</span>xahot.tar.gz /xahot<br>zip -r .<span class=\"hljs-regexp\">/xahot.zip ./</span>* -r<br><br><br>解压：<br>tar –xvf file.tar <span class=\"hljs-regexp\">//</span>解压 tar包<br>tar -xzvf file.tar.gz <span class=\"hljs-regexp\">//</span>解压tar.gz<br>tar -xjvf file.tar.bz2   <span class=\"hljs-regexp\">//</span>解压 tar.bz2<br>tar –xZvf file.tar.Z   <span class=\"hljs-regexp\">//</span>解压tar.Z<br>unrar e file.rar <span class=\"hljs-regexp\">//</span>解压rar<br>unzip file.zip <span class=\"hljs-regexp\">//</span>解压zip<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">查看当前进程的线程数量<br><span class=\"hljs-comment\"># pstree -p 进程号 | wc -l</span><br><br>查看文件夹下文件数量<br><span class=\"hljs-comment\"># ls | wc -w</span><br><br>查看磁盘占用：<br><span class=\"hljs-comment\"># df -h</span><br><br>查看内存占用<br><span class=\"hljs-comment\"># free -m</span><br><br>查看端口占用<br><span class=\"hljs-comment\"># netstat -anp | grep 端口号</span><br><br>查看全部端口占用<br><span class=\"hljs-comment\"># netstat -nultp</span><br><br>查看机器是固态还是机械<br><span class=\"hljs-comment\"># lsblk -d -o name,rota</span><br>对于其返回值，看rota值来判断，如果rota为<span class=\"hljs-number\">1</span>，则意味旋转，则为机械盘，若rota为<span class=\"hljs-number\">0</span>则意味着发该盘为固态<br><br>查看硬盘信息<br><span class=\"hljs-comment\"># fdisk -l</span><br><span class=\"hljs-comment\"># hdparm -i /dev/sda1</span><br><span class=\"hljs-comment\"># hdparm -i /dev/sdb1 |grep -i serialno</span><br>SerialNo=Z1Z0MKWS 硬盘序列号<br><br>vim中查询计数（例：查yes）<br><span class=\"hljs-comment\"># :%s/yes//gn</span><br><br>查看某个进程的线程数<br><span class=\"hljs-comment\"># pstree -p 进程id | wc -l</span><br><br>远程复制<br><span class=\"hljs-comment\"># scp -r flume/ hadoop@hadoop03:$PWD</span><br><br>查看cpu个数<br><span class=\"hljs-comment\"># lscpu</span><br> <br>每个cpu的核数<br><span class=\"hljs-comment\">#cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</span><br> <br>查看内存总数<br><span class=\"hljs-comment\">#cat /proc/meminfo | grep MemTotal</span><br><br>修改拥有者（chown）<br><span class=\"hljs-comment\"># chown hadoop:hadoop rootfs</span><br><br>修改权限（chmod ）<br>  文字设定法<br><span class=\"hljs-comment\"># chmod [who] [+ | - | =] [mode] 文件名</span><br>  eg: chmod g+r，o+r example<br>    who：<br>      u 表示“用户（user）”，即文件或目录的所有者。<br>      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>      o 表示“其他（others）用户”。<br>      a 表示“所有（all）用户”。它是系统默认值。<br>    操作符：<br>      + 添加某个权限。<br>      - 取消某个权限。<br>      = 赋予给定权限并取消其他所有权限（如果有的话）。<br>    mode：<br>      r 可读。<br>      w 可写。<br>      x 可执行。<br>      X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。<br>      s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。<br>      t 保存程序的文本到交换设备上。<br>      u 与文件属主拥有一样的权限。<br>      g 与和文件属主同组的用户拥有一样的权限。<br>      o 与其他用户拥有一样的权限。<br>  数字设定法<br><span class=\"hljs-comment\"># chmod [mode] 文件名</span><br><span class=\"hljs-number\">0</span>表示没有权限，<span class=\"hljs-number\">1</span>表示可执行权限，<span class=\"hljs-number\">2</span>表示可写权限，<span class=\"hljs-number\">4</span>表示可读权限，然后将其相加。<br><br><br>[viewer@ tomcat]$ ll<br>total <span class=\"hljs-number\">160</span><br>-rw-r----- <span class=\"hljs-number\">1</span> root root  <span class=\"hljs-number\">7142</span> Dec <span class=\"hljs-number\">12</span>  <span class=\"hljs-number\">2018</span> RELEASE-NOTES<br>-rw-r----- <span class=\"hljs-number\">1</span> root root <span class=\"hljs-number\">16262</span> Dec <span class=\"hljs-number\">12</span>  <span class=\"hljs-number\">2018</span> RUNNING.txt<br>drwxr-x--- <span class=\"hljs-number\">2</span> root root  <span class=\"hljs-number\">4096</span> Feb <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">34</span> temp<br>drwxr-x--- <span class=\"hljs-number\">4</span> root root  <span class=\"hljs-number\">4096</span> Apr <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">36</span> webapps<br>drwxr-x--- <span class=\"hljs-number\">3</span> root root  <span class=\"hljs-number\">4096</span> Feb <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">35</span> work<br><br><span class=\"hljs-comment\">#清除cache</span><br>echo <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除pagecache。<br>echo <span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。<br>echo <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-regexp\">/proc/</span>sys<span class=\"hljs-regexp\">/vm/</span>drop_caches:表示清除pagecache和slab分配器中的缓存对象。<br><br>从本地复制到远程<br><span class=\"hljs-comment\"># 拷贝文件</span><br>scp <span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/test.txt root@192.168.0.2:/</span>home<span class=\"hljs-regexp\">/test/</span><br><span class=\"hljs-comment\"># 拷贝目录</span><br>scp -r <span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ root@192.168.0.2:/</span>home<span class=\"hljs-regexp\">/test/</span><br><br>从远程复制到本地<br><span class=\"hljs-comment\"># 拷贝文件</span><br>scp root@<span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">0.2</span>:<span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ /</span>home<span class=\"hljs-regexp\">/test/</span>test.txt<br><span class=\"hljs-comment\"># 拷贝目录</span><br>scp -r root@<span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">0.2</span>:<span class=\"hljs-regexp\">/home/</span>test<span class=\"hljs-regexp\">/ v/</span>home<span class=\"hljs-regexp\">/test/</span><br><br><span class=\"hljs-comment\"># 压缩解压</span><br>压缩：<br>tar -zcvf <span class=\"hljs-regexp\">/home/</span>xahot.tar.gz /xahot<br>zip -r .<span class=\"hljs-regexp\">/xahot.zip ./</span>* -r<br><br><br>解压：<br>tar –xvf file.tar <span class=\"hljs-regexp\">//</span>解压 tar包<br>tar -xzvf file.tar.gz <span class=\"hljs-regexp\">//</span>解压tar.gz<br>tar -xjvf file.tar.bz2   <span class=\"hljs-regexp\">//</span>解压 tar.bz2<br>tar –xZvf file.tar.Z   <span class=\"hljs-regexp\">//</span>解压tar.Z<br>unrar e file.rar <span class=\"hljs-regexp\">//</span>解压rar<br>unzip file.zip <span class=\"hljs-regexp\">//</span>解压zip<br></code></pre></td></tr></table></figure>\n"},{"title":"前端模块化比较","date":"2020-03-10T10:13:15.000Z","excerpt":"前端模块化比较","position":null,"image_url":null,"_content":"参考链接：https://blog.csdn.net/haochangdi123/article/details/80408874\n\n### commonJs和es6比较总结\n1. CommonJS模块输出是一个值的拷贝，ES6模块输出是值的引用。\n2. CommonJS模块是运行时加载，ES6模块是编译时输出接口。\n3. CommonJS模块无论require多少次，都只会在第一次加载时运行一次，然后保存到缓存中，下次在require，只会去从缓存取。\n\n\n### 一、commonJs\n1. 运行在服务端，node模块化，webpack就是以此写的node模块。浏览器不兼容。\n2. 特性：同步。\n3. 模块：引用(require) ， 定义(exports) ，标识(module)。\n4. 浏览器不兼容CommonJS的根本原因，也正是在于缺少四个Node.js环境的变量。\n    - module\n    - exports\n    - require\n    - global\n\n### 二、AMD\n1. 特性：异步。代表：require.js\n2. 先引入的模块，后使用引用模块的方法，所以我们称之为依赖前置。\n\n### 三、CMD\n1. 特性：异步。代表：sea.js\n2. 通用模块定义。依赖就近原则\n\n### 四、es6\n上述commonJs，AMD，CMD都是ES5时期，ES6中已经实现模块化，完全可以取代他们的规范，成为浏览器和服务器通用的模块解决方案。\n1. ES6 模块的设计思想是尽量的**静态化**，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。\n\n### 五、require和import区别\n1. 模块加载的时间\n    - require：运行时加载\n    - import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】\n2. require：模块就是对象，输入时必须查找对象属性\n    - require实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法\n    - ES6模块，实质上从fs模块加载对应的方法，其他方法不加载\n3. CommonJS 模块输出的是一个`值的拷贝`，ES6 模块输出的是`值的引用`\n\n### 六、module.exports 和 exports方法的区别\n1. export是设置导出模块对象的指定属性，可以导出多个\n2. module.export既可以设置导出模块的所有属性，又可以设置导出模块的指定属性。**如果说设置位到出所有属性，module.exports只认最后一次导出设置**\n\n```\n//exports使用方式\n// 可以多次导出多个属性\nexports.func = str => console.log(str)\nexports.test = str => console.log(str)\n// 返回结果 { func : [Function] , test : [Function] }\n\n\n// module.exports导出所有，只认最后一次导出设置\nmodule.exports = {\n\tfunc: str => console.log(str)\n}\nmodule.exports = {\n\ttest : str => console.log(str)\n}\n// 返回结果 { test : [Function: test] }\n```\n### 七、ES6使用export和import来导出/导入模块。\n1. export与export default均可用于导出常量/函数/文件/模块等；\n2. 在一个文件或模块中，export/import可以有多个，export default只有一个；\n3. 通过export方式导出，在导入时需要加{}，export default不需要；\n4. export能导出变量/表达式，export default不可以。\n\n总结：\n- module.exports与exports ，是CommonJS的规范，被使用于Node.js中。\n- export与export default ，是ES6规范，被使用于React或Vue中。\n","source":"_posts/module.md","raw":"---\ntitle: 前端模块化比较\ndate: 2020-03-10 18:13:15\nexcerpt: 前端模块化比较\ntags: js\nposition:\nimage_url:\n---\n参考链接：https://blog.csdn.net/haochangdi123/article/details/80408874\n\n### commonJs和es6比较总结\n1. CommonJS模块输出是一个值的拷贝，ES6模块输出是值的引用。\n2. CommonJS模块是运行时加载，ES6模块是编译时输出接口。\n3. CommonJS模块无论require多少次，都只会在第一次加载时运行一次，然后保存到缓存中，下次在require，只会去从缓存取。\n\n\n### 一、commonJs\n1. 运行在服务端，node模块化，webpack就是以此写的node模块。浏览器不兼容。\n2. 特性：同步。\n3. 模块：引用(require) ， 定义(exports) ，标识(module)。\n4. 浏览器不兼容CommonJS的根本原因，也正是在于缺少四个Node.js环境的变量。\n    - module\n    - exports\n    - require\n    - global\n\n### 二、AMD\n1. 特性：异步。代表：require.js\n2. 先引入的模块，后使用引用模块的方法，所以我们称之为依赖前置。\n\n### 三、CMD\n1. 特性：异步。代表：sea.js\n2. 通用模块定义。依赖就近原则\n\n### 四、es6\n上述commonJs，AMD，CMD都是ES5时期，ES6中已经实现模块化，完全可以取代他们的规范，成为浏览器和服务器通用的模块解决方案。\n1. ES6 模块的设计思想是尽量的**静态化**，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。\n\n### 五、require和import区别\n1. 模块加载的时间\n    - require：运行时加载\n    - import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】\n2. require：模块就是对象，输入时必须查找对象属性\n    - require实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法\n    - ES6模块，实质上从fs模块加载对应的方法，其他方法不加载\n3. CommonJS 模块输出的是一个`值的拷贝`，ES6 模块输出的是`值的引用`\n\n### 六、module.exports 和 exports方法的区别\n1. export是设置导出模块对象的指定属性，可以导出多个\n2. module.export既可以设置导出模块的所有属性，又可以设置导出模块的指定属性。**如果说设置位到出所有属性，module.exports只认最后一次导出设置**\n\n```\n//exports使用方式\n// 可以多次导出多个属性\nexports.func = str => console.log(str)\nexports.test = str => console.log(str)\n// 返回结果 { func : [Function] , test : [Function] }\n\n\n// module.exports导出所有，只认最后一次导出设置\nmodule.exports = {\n\tfunc: str => console.log(str)\n}\nmodule.exports = {\n\ttest : str => console.log(str)\n}\n// 返回结果 { test : [Function: test] }\n```\n### 七、ES6使用export和import来导出/导入模块。\n1. export与export default均可用于导出常量/函数/文件/模块等；\n2. 在一个文件或模块中，export/import可以有多个，export default只有一个；\n3. 通过export方式导出，在导入时需要加{}，export default不需要；\n4. export能导出变量/表达式，export default不可以。\n\n总结：\n- module.exports与exports ，是CommonJS的规范，被使用于Node.js中。\n- export与export default ，是ES6规范，被使用于React或Vue中。\n","slug":"module","published":1,"updated":"2021-05-11T01:57:29.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknb00111kwacckvffyj","content":"<p>参考链接：<a href=\"https://blog.csdn.net/haochangdi123/article/details/80408874\">https://blog.csdn.net/haochangdi123/article/details/80408874</a></p>\n<h3 id=\"commonJs和es6比较总结\"><a href=\"#commonJs和es6比较总结\" class=\"headerlink\" title=\"commonJs和es6比较总结\"></a>commonJs和es6比较总结</h3><ol>\n<li>CommonJS模块输出是一个值的拷贝，ES6模块输出是值的引用。</li>\n<li>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</li>\n<li>CommonJS模块无论require多少次，都只会在第一次加载时运行一次，然后保存到缓存中，下次在require，只会去从缓存取。</li>\n</ol>\n<h3 id=\"一、commonJs\"><a href=\"#一、commonJs\" class=\"headerlink\" title=\"一、commonJs\"></a>一、commonJs</h3><ol>\n<li>运行在服务端，node模块化，webpack就是以此写的node模块。浏览器不兼容。</li>\n<li>特性：同步。</li>\n<li>模块：引用(require) ， 定义(exports) ，标识(module)。</li>\n<li>浏览器不兼容CommonJS的根本原因，也正是在于缺少四个Node.js环境的变量。<ul>\n<li>module</li>\n<li>exports</li>\n<li>require</li>\n<li>global</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"二、AMD\"><a href=\"#二、AMD\" class=\"headerlink\" title=\"二、AMD\"></a>二、AMD</h3><ol>\n<li>特性：异步。代表：require.js</li>\n<li>先引入的模块，后使用引用模块的方法，所以我们称之为依赖前置。</li>\n</ol>\n<h3 id=\"三、CMD\"><a href=\"#三、CMD\" class=\"headerlink\" title=\"三、CMD\"></a>三、CMD</h3><ol>\n<li>特性：异步。代表：sea.js</li>\n<li>通用模块定义。依赖就近原则</li>\n</ol>\n<h3 id=\"四、es6\"><a href=\"#四、es6\" class=\"headerlink\" title=\"四、es6\"></a>四、es6</h3><p>上述commonJs，AMD，CMD都是ES5时期，ES6中已经实现模块化，完全可以取代他们的规范，成为浏览器和服务器通用的模块解决方案。</p>\n<ol>\n<li>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</li>\n</ol>\n<h3 id=\"五、require和import区别\"><a href=\"#五、require和import区别\" class=\"headerlink\" title=\"五、require和import区别\"></a>五、require和import区别</h3><ol>\n<li>模块加载的时间<ul>\n<li>require：运行时加载</li>\n<li>import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】</li>\n</ul>\n</li>\n<li>require：模块就是对象，输入时必须查找对象属性<ul>\n<li>require实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法</li>\n<li>ES6模块，实质上从fs模块加载对应的方法，其他方法不加载</li>\n</ul>\n</li>\n<li>CommonJS 模块输出的是一个<code>值的拷贝</code>，ES6 模块输出的是<code>值的引用</code></li>\n</ol>\n<h3 id=\"六、module-exports-和-exports方法的区别\"><a href=\"#六、module-exports-和-exports方法的区别\" class=\"headerlink\" title=\"六、module.exports 和 exports方法的区别\"></a>六、module.exports 和 exports方法的区别</h3><ol>\n<li>export是设置导出模块对象的指定属性，可以导出多个</li>\n<li>module.export既可以设置导出模块的所有属性，又可以设置导出模块的指定属性。<strong>如果说设置位到出所有属性，module.exports只认最后一次导出设置</strong></li>\n</ol>\n<figure class=\"highlight openscad\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs openscad\"><span class=\"hljs-comment\">//exports使用方式</span><br><span class=\"hljs-comment\">// 可以多次导出多个属性</span><br>exports.func = <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>exports.test = <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br><span class=\"hljs-comment\">// 返回结果 &#123; func : [Function] , test : [Function] &#125;</span><br><br><br><span class=\"hljs-comment\">// module.exports导出所有，只认最后一次导出设置</span><br><span class=\"hljs-keyword\">module</span>.exports = &#123;<br>\tfunc: <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>&#125;<br><span class=\"hljs-keyword\">module</span>.exports = &#123;<br>\ttest : <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>&#125;<br><span class=\"hljs-comment\">// 返回结果 &#123; test : [Function: test] &#125;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"七、ES6使用export和import来导出-导入模块。\"><a href=\"#七、ES6使用export和import来导出-导入模块。\" class=\"headerlink\" title=\"七、ES6使用export和import来导出/导入模块。\"></a>七、ES6使用export和import来导出/导入模块。</h3><ol>\n<li>export与export default均可用于导出常量/函数/文件/模块等；</li>\n<li>在一个文件或模块中，export/import可以有多个，export default只有一个；</li>\n<li>通过export方式导出，在导入时需要加{}，export default不需要；</li>\n<li>export能导出变量/表达式，export default不可以。</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>module.exports与exports ，是CommonJS的规范，被使用于Node.js中。</li>\n<li>export与export default ，是ES6规范，被使用于React或Vue中。</li>\n</ul>\n","site":{"data":{}},"more":"<p>参考链接：<a href=\"https://blog.csdn.net/haochangdi123/article/details/80408874\">https://blog.csdn.net/haochangdi123/article/details/80408874</a></p>\n<h3 id=\"commonJs和es6比较总结\"><a href=\"#commonJs和es6比较总结\" class=\"headerlink\" title=\"commonJs和es6比较总结\"></a>commonJs和es6比较总结</h3><ol>\n<li>CommonJS模块输出是一个值的拷贝，ES6模块输出是值的引用。</li>\n<li>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</li>\n<li>CommonJS模块无论require多少次，都只会在第一次加载时运行一次，然后保存到缓存中，下次在require，只会去从缓存取。</li>\n</ol>\n<h3 id=\"一、commonJs\"><a href=\"#一、commonJs\" class=\"headerlink\" title=\"一、commonJs\"></a>一、commonJs</h3><ol>\n<li>运行在服务端，node模块化，webpack就是以此写的node模块。浏览器不兼容。</li>\n<li>特性：同步。</li>\n<li>模块：引用(require) ， 定义(exports) ，标识(module)。</li>\n<li>浏览器不兼容CommonJS的根本原因，也正是在于缺少四个Node.js环境的变量。<ul>\n<li>module</li>\n<li>exports</li>\n<li>require</li>\n<li>global</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"二、AMD\"><a href=\"#二、AMD\" class=\"headerlink\" title=\"二、AMD\"></a>二、AMD</h3><ol>\n<li>特性：异步。代表：require.js</li>\n<li>先引入的模块，后使用引用模块的方法，所以我们称之为依赖前置。</li>\n</ol>\n<h3 id=\"三、CMD\"><a href=\"#三、CMD\" class=\"headerlink\" title=\"三、CMD\"></a>三、CMD</h3><ol>\n<li>特性：异步。代表：sea.js</li>\n<li>通用模块定义。依赖就近原则</li>\n</ol>\n<h3 id=\"四、es6\"><a href=\"#四、es6\" class=\"headerlink\" title=\"四、es6\"></a>四、es6</h3><p>上述commonJs，AMD，CMD都是ES5时期，ES6中已经实现模块化，完全可以取代他们的规范，成为浏览器和服务器通用的模块解决方案。</p>\n<ol>\n<li>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</li>\n</ol>\n<h3 id=\"五、require和import区别\"><a href=\"#五、require和import区别\" class=\"headerlink\" title=\"五、require和import区别\"></a>五、require和import区别</h3><ol>\n<li>模块加载的时间<ul>\n<li>require：运行时加载</li>\n<li>import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】</li>\n</ul>\n</li>\n<li>require：模块就是对象，输入时必须查找对象属性<ul>\n<li>require实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法</li>\n<li>ES6模块，实质上从fs模块加载对应的方法，其他方法不加载</li>\n</ul>\n</li>\n<li>CommonJS 模块输出的是一个<code>值的拷贝</code>，ES6 模块输出的是<code>值的引用</code></li>\n</ol>\n<h3 id=\"六、module-exports-和-exports方法的区别\"><a href=\"#六、module-exports-和-exports方法的区别\" class=\"headerlink\" title=\"六、module.exports 和 exports方法的区别\"></a>六、module.exports 和 exports方法的区别</h3><ol>\n<li>export是设置导出模块对象的指定属性，可以导出多个</li>\n<li>module.export既可以设置导出模块的所有属性，又可以设置导出模块的指定属性。<strong>如果说设置位到出所有属性，module.exports只认最后一次导出设置</strong></li>\n</ol>\n<figure class=\"highlight openscad\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs openscad\"><span class=\"hljs-comment\">//exports使用方式</span><br><span class=\"hljs-comment\">// 可以多次导出多个属性</span><br>exports.func = <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>exports.test = <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br><span class=\"hljs-comment\">// 返回结果 &#123; func : [Function] , test : [Function] &#125;</span><br><br><br><span class=\"hljs-comment\">// module.exports导出所有，只认最后一次导出设置</span><br><span class=\"hljs-keyword\">module</span>.exports = &#123;<br>\tfunc: <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>&#125;<br><span class=\"hljs-keyword\">module</span>.exports = &#123;<br>\ttest : <span class=\"hljs-built_in\">str</span> =&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">str</span>)<br>&#125;<br><span class=\"hljs-comment\">// 返回结果 &#123; test : [Function: test] &#125;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"七、ES6使用export和import来导出-导入模块。\"><a href=\"#七、ES6使用export和import来导出-导入模块。\" class=\"headerlink\" title=\"七、ES6使用export和import来导出/导入模块。\"></a>七、ES6使用export和import来导出/导入模块。</h3><ol>\n<li>export与export default均可用于导出常量/函数/文件/模块等；</li>\n<li>在一个文件或模块中，export/import可以有多个，export default只有一个；</li>\n<li>通过export方式导出，在导入时需要加{}，export default不需要；</li>\n<li>export能导出变量/表达式，export default不可以。</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>module.exports与exports ，是CommonJS的规范，被使用于Node.js中。</li>\n<li>export与export default ，是ES6规范，被使用于React或Vue中。</li>\n</ul>\n"},{"title":"rxjs","date":"2020-04-10T08:44:52.000Z","excerpt":"rxjs","position":null,"image_url":null,"_content":"\nRxjs：异步编程。angular已经集成了。\n\n###### 目前常见的异步编程的几种方法：\n1. 回调函数\n1. 事件监听/发布订阅\n1. Promise\n1. Rxjs\n\n![image](/images/rxjs/clipboard3.png)\n\n##### 前提：Promise 的缺点\nPromise 固然是一个重大的进步，但在有些场景下仍然是不够的。比如，Promise 的特点是无论有没有人关心它的执行结果，它都会立即开始执行，并且你没有机会取消这次执行。显然，在某些情况下这么做是浪费的甚至错误的。仍然以电商为例，如果某商户的订单不允许取消，你还会去买吗？再举个编程领域的例子：如果你发起了一个 Ajax 请求，然后用户导航到了另一个路由，显然，你这个请求如果还没有完成就应该被取消，而不应该发出去。但是使用 Promise，你做不到，不是因为实现方面的原因，而是因为它在概念层（接口定义上）就无法支持取消。\n\n此外，由于 Promise 只会承载一个值，因此当我们要处理的是一个集合的时候就比较困难了。比如对于一个随机数列（总数未知），如果我们要借助 Web API 检查每个数字的有效性，然后对前一百个有效数字进行求和，那么用 Promise 写就比较麻烦了。\n我们需要一个更高级的 Promise。\n\n##### 一、Observable\n它就是可观察对象（Observable [əbˈzɜrvəbl]），Observable 顾名思义就是可以被别人观察的对象，当它变化时，观察者就可以得到通知。换句话说，它负责生产数据，别人可以消费它生产的数据。\n\n如果你是个资深后端，那么可能还记得 MessageQueue 的工作模式，它们很像。如果不懂 MQ 也没关系，我还是用日常知识给你打个比方。\n\nObservable 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人。\n\n整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可，简单、高效、无意外 —— 符合程序员的审美。\n\n而且这个生产线还非常先进 —— 不接单就不生产，非常有效地杜绝了浪费。\n##### 二、FRP\n这种设计，看上去很美，对吧？但光看着漂亮可不行，在编程时要怎么实现呢？实际上，这是一种编程范式，叫做函数响应式编程（FRP）。它比 Promise 可年轻多了，直到 1997 年才被人提出来。\n\n顾名思义，FRP 同时具有函数式编程和响应式编程的特点。响应式编程是什么呢？形象的说，它的工作模式就是“饭来张口，衣来伸手”，也就是说，等待外界的输入，并做出响应。流水线每个工位上的工人正是这种工作模式。\n\n工业上，流水线是人类管理经验的结晶，它所做的事情是什么呢？本质上就是把每个处理都局部化，以减小复杂度（降低对工人素质的要求）。而这，正是软件行业所求之不得的。响应式，就是编程领域的流水线。\n\n那么函数式呢？函数式最显著的特征就是没有副作用，而这恰好是对流水线上每个工序的要求。显然，如果某个工序的操作会导致整个生产线平移 10 米，那么用不了多久这个生产线就要掉到海里了，这样的生产线毫无价值。\n因此，响应式和函数式几乎是注定要在一起的。\n##### 三、RxJS\n**RXJS是Observable的Javascript实现**\n\nRxJS 就是 ReactiveX 在 JavaScript 语言上的实现。对于 JavaScript 程序员来说，不管你是前端还是 NodeJS 后端，RxJS 都会令你受益。\n由于 JavaScript 本身的缺陷，RxJS 不得不采用了很多怪异的写法。它对于 Java / C# 等背景的程序员来说可能会显得比较怪异，不过，你可以先忽略它们，聚焦在编程范式和接下来要讲的操作符语义上。\n\n```\n典型的写法\nof(1,2,3).pipe(\n  filter(item=>item % 2 === 1),\n  map(item=>item * 3),\n).subscribe(item=> console.log(item))\n它会输出：\n3\n9\n```\n\n其中 of 称为创建器（creator），用来创建流，它返回一个 Observable 类型的对象，filter 和 map 称为操作符（operator），用来对条目进行处理。这些操作符被当作 Observable 对象的 pipe 方法的参数传进去。诚然，这个写法略显怪异，不过这主要是被 js 的设计缺陷所迫，它已经是目前 js 体系下多种解决方案中相对好看的一种了。\nObservable 对象的 subscribe 方法表示消费者要订阅这个流，当流中出现数据时，传给 subscribe 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据。\n\n**注意，Observable 必须被 subscribe 之后才会开始生产数据。如果没人 subscribe 它，那就什么都不会做。**\n\n\n##### 四、rxjs和promise的区别\n![image](/images/rxjs/clipboard.png)\n\npromise相较于Rxjs而言功能更单一 promise 只能将一个数据的状态由pending转换成resoloved或者rejected.而Rxjs可以处理多个数据对应complete和error状态但是Rxjs同时又拥有next方法。Observable是惰性的，需要subscribe的时候才输出值。promise内部状态是不可控制的，执行了就无法终止。而Observable可以定义如何取消异步方法。这也就是我下面会讨论到的一个异步场景。\n\n##### 五、详解\n###### 在 RxJS 中用来解决异步事件管理的的基本概念是：\n1. Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n1. Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n1. Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。\n1. Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。\n1. Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n1. Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。\n\n![image](/images/rxjs/clipboard2.png)\n\nObservable 是同步的。\n\n函数和 Observables 都是惰性运算。如果你不调用函数，console.log('Hello') 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log('Hello') 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。\nObservable 可以随着时间的推移“返回”多个值，这是函数所做不到的。Observables 传递值可以是同步的，也可以是异步的。\n\nObservable 的核心关注点：\n- 创建 Observables\n- 订阅 Observables\n- 执行 Observables\n- 清理 Observables\n\n","source":"_posts/rxjs.md","raw":"---\ntitle: rxjs\ndate: 2020-04-10 16:44:52\nexcerpt: rxjs\ntags: rxjs\nposition:\nimage_url:\n---\n\nRxjs：异步编程。angular已经集成了。\n\n###### 目前常见的异步编程的几种方法：\n1. 回调函数\n1. 事件监听/发布订阅\n1. Promise\n1. Rxjs\n\n![image](/images/rxjs/clipboard3.png)\n\n##### 前提：Promise 的缺点\nPromise 固然是一个重大的进步，但在有些场景下仍然是不够的。比如，Promise 的特点是无论有没有人关心它的执行结果，它都会立即开始执行，并且你没有机会取消这次执行。显然，在某些情况下这么做是浪费的甚至错误的。仍然以电商为例，如果某商户的订单不允许取消，你还会去买吗？再举个编程领域的例子：如果你发起了一个 Ajax 请求，然后用户导航到了另一个路由，显然，你这个请求如果还没有完成就应该被取消，而不应该发出去。但是使用 Promise，你做不到，不是因为实现方面的原因，而是因为它在概念层（接口定义上）就无法支持取消。\n\n此外，由于 Promise 只会承载一个值，因此当我们要处理的是一个集合的时候就比较困难了。比如对于一个随机数列（总数未知），如果我们要借助 Web API 检查每个数字的有效性，然后对前一百个有效数字进行求和，那么用 Promise 写就比较麻烦了。\n我们需要一个更高级的 Promise。\n\n##### 一、Observable\n它就是可观察对象（Observable [əbˈzɜrvəbl]），Observable 顾名思义就是可以被别人观察的对象，当它变化时，观察者就可以得到通知。换句话说，它负责生产数据，别人可以消费它生产的数据。\n\n如果你是个资深后端，那么可能还记得 MessageQueue 的工作模式，它们很像。如果不懂 MQ 也没关系，我还是用日常知识给你打个比方。\n\nObservable 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人。\n\n整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可，简单、高效、无意外 —— 符合程序员的审美。\n\n而且这个生产线还非常先进 —— 不接单就不生产，非常有效地杜绝了浪费。\n##### 二、FRP\n这种设计，看上去很美，对吧？但光看着漂亮可不行，在编程时要怎么实现呢？实际上，这是一种编程范式，叫做函数响应式编程（FRP）。它比 Promise 可年轻多了，直到 1997 年才被人提出来。\n\n顾名思义，FRP 同时具有函数式编程和响应式编程的特点。响应式编程是什么呢？形象的说，它的工作模式就是“饭来张口，衣来伸手”，也就是说，等待外界的输入，并做出响应。流水线每个工位上的工人正是这种工作模式。\n\n工业上，流水线是人类管理经验的结晶，它所做的事情是什么呢？本质上就是把每个处理都局部化，以减小复杂度（降低对工人素质的要求）。而这，正是软件行业所求之不得的。响应式，就是编程领域的流水线。\n\n那么函数式呢？函数式最显著的特征就是没有副作用，而这恰好是对流水线上每个工序的要求。显然，如果某个工序的操作会导致整个生产线平移 10 米，那么用不了多久这个生产线就要掉到海里了，这样的生产线毫无价值。\n因此，响应式和函数式几乎是注定要在一起的。\n##### 三、RxJS\n**RXJS是Observable的Javascript实现**\n\nRxJS 就是 ReactiveX 在 JavaScript 语言上的实现。对于 JavaScript 程序员来说，不管你是前端还是 NodeJS 后端，RxJS 都会令你受益。\n由于 JavaScript 本身的缺陷，RxJS 不得不采用了很多怪异的写法。它对于 Java / C# 等背景的程序员来说可能会显得比较怪异，不过，你可以先忽略它们，聚焦在编程范式和接下来要讲的操作符语义上。\n\n```\n典型的写法\nof(1,2,3).pipe(\n  filter(item=>item % 2 === 1),\n  map(item=>item * 3),\n).subscribe(item=> console.log(item))\n它会输出：\n3\n9\n```\n\n其中 of 称为创建器（creator），用来创建流，它返回一个 Observable 类型的对象，filter 和 map 称为操作符（operator），用来对条目进行处理。这些操作符被当作 Observable 对象的 pipe 方法的参数传进去。诚然，这个写法略显怪异，不过这主要是被 js 的设计缺陷所迫，它已经是目前 js 体系下多种解决方案中相对好看的一种了。\nObservable 对象的 subscribe 方法表示消费者要订阅这个流，当流中出现数据时，传给 subscribe 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据。\n\n**注意，Observable 必须被 subscribe 之后才会开始生产数据。如果没人 subscribe 它，那就什么都不会做。**\n\n\n##### 四、rxjs和promise的区别\n![image](/images/rxjs/clipboard.png)\n\npromise相较于Rxjs而言功能更单一 promise 只能将一个数据的状态由pending转换成resoloved或者rejected.而Rxjs可以处理多个数据对应complete和error状态但是Rxjs同时又拥有next方法。Observable是惰性的，需要subscribe的时候才输出值。promise内部状态是不可控制的，执行了就无法终止。而Observable可以定义如何取消异步方法。这也就是我下面会讨论到的一个异步场景。\n\n##### 五、详解\n###### 在 RxJS 中用来解决异步事件管理的的基本概念是：\n1. Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n1. Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n1. Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。\n1. Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。\n1. Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n1. Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。\n\n![image](/images/rxjs/clipboard2.png)\n\nObservable 是同步的。\n\n函数和 Observables 都是惰性运算。如果你不调用函数，console.log('Hello') 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log('Hello') 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。\nObservable 可以随着时间的推移“返回”多个值，这是函数所做不到的。Observables 传递值可以是同步的，也可以是异步的。\n\nObservable 的核心关注点：\n- 创建 Observables\n- 订阅 Observables\n- 执行 Observables\n- 清理 Observables\n\n","slug":"rxjs","published":1,"updated":"2021-05-10T08:57:35.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknc00121kwaao20ay60","content":"<p>Rxjs：异步编程。angular已经集成了。</p>\n<h6 id=\"目前常见的异步编程的几种方法：\"><a href=\"#目前常见的异步编程的几种方法：\" class=\"headerlink\" title=\"目前常见的异步编程的几种方法：\"></a>目前常见的异步编程的几种方法：</h6><ol>\n<li>回调函数</li>\n<li>事件监听/发布订阅</li>\n<li>Promise</li>\n<li>Rxjs</li>\n</ol>\n<p><img src=\"/images/rxjs/clipboard3.png\" alt=\"image\"></p>\n<h5 id=\"前提：Promise-的缺点\"><a href=\"#前提：Promise-的缺点\" class=\"headerlink\" title=\"前提：Promise 的缺点\"></a>前提：Promise 的缺点</h5><p>Promise 固然是一个重大的进步，但在有些场景下仍然是不够的。比如，Promise 的特点是无论有没有人关心它的执行结果，它都会立即开始执行，并且你没有机会取消这次执行。显然，在某些情况下这么做是浪费的甚至错误的。仍然以电商为例，如果某商户的订单不允许取消，你还会去买吗？再举个编程领域的例子：如果你发起了一个 Ajax 请求，然后用户导航到了另一个路由，显然，你这个请求如果还没有完成就应该被取消，而不应该发出去。但是使用 Promise，你做不到，不是因为实现方面的原因，而是因为它在概念层（接口定义上）就无法支持取消。</p>\n<p>此外，由于 Promise 只会承载一个值，因此当我们要处理的是一个集合的时候就比较困难了。比如对于一个随机数列（总数未知），如果我们要借助 Web API 检查每个数字的有效性，然后对前一百个有效数字进行求和，那么用 Promise 写就比较麻烦了。<br>我们需要一个更高级的 Promise。</p>\n<h5 id=\"一、Observable\"><a href=\"#一、Observable\" class=\"headerlink\" title=\"一、Observable\"></a>一、Observable</h5><p>它就是可观察对象（Observable [əbˈzɜrvəbl]），Observable 顾名思义就是可以被别人观察的对象，当它变化时，观察者就可以得到通知。换句话说，它负责生产数据，别人可以消费它生产的数据。</p>\n<p>如果你是个资深后端，那么可能还记得 MessageQueue 的工作模式，它们很像。如果不懂 MQ 也没关系，我还是用日常知识给你打个比方。</p>\n<p>Observable 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人。</p>\n<p>整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可，简单、高效、无意外 —— 符合程序员的审美。</p>\n<p>而且这个生产线还非常先进 —— 不接单就不生产，非常有效地杜绝了浪费。</p>\n<h5 id=\"二、FRP\"><a href=\"#二、FRP\" class=\"headerlink\" title=\"二、FRP\"></a>二、FRP</h5><p>这种设计，看上去很美，对吧？但光看着漂亮可不行，在编程时要怎么实现呢？实际上，这是一种编程范式，叫做函数响应式编程（FRP）。它比 Promise 可年轻多了，直到 1997 年才被人提出来。</p>\n<p>顾名思义，FRP 同时具有函数式编程和响应式编程的特点。响应式编程是什么呢？形象的说，它的工作模式就是“饭来张口，衣来伸手”，也就是说，等待外界的输入，并做出响应。流水线每个工位上的工人正是这种工作模式。</p>\n<p>工业上，流水线是人类管理经验的结晶，它所做的事情是什么呢？本质上就是把每个处理都局部化，以减小复杂度（降低对工人素质的要求）。而这，正是软件行业所求之不得的。响应式，就是编程领域的流水线。</p>\n<p>那么函数式呢？函数式最显著的特征就是没有副作用，而这恰好是对流水线上每个工序的要求。显然，如果某个工序的操作会导致整个生产线平移 10 米，那么用不了多久这个生产线就要掉到海里了，这样的生产线毫无价值。<br>因此，响应式和函数式几乎是注定要在一起的。</p>\n<h5 id=\"三、RxJS\"><a href=\"#三、RxJS\" class=\"headerlink\" title=\"三、RxJS\"></a>三、RxJS</h5><p><strong>RXJS是Observable的Javascript实现</strong></p>\n<p>RxJS 就是 ReactiveX 在 JavaScript 语言上的实现。对于 JavaScript 程序员来说，不管你是前端还是 NodeJS 后端，RxJS 都会令你受益。<br>由于 JavaScript 本身的缺陷，RxJS 不得不采用了很多怪异的写法。它对于 Java / C# 等背景的程序员来说可能会显得比较怪异，不过，你可以先忽略它们，聚焦在编程范式和接下来要讲的操作符语义上。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">典型的写法<br><span class=\"hljs-keyword\">of</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>).pipe(<br>  <span class=\"hljs-built_in\">filter</span>(<span class=\"hljs-keyword\">item</span>=&gt;<span class=\"hljs-keyword\">item</span> % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">1</span>),<br>  map(<span class=\"hljs-keyword\">item</span>=&gt;<span class=\"hljs-keyword\">item</span> * <span class=\"hljs-number\">3</span>),<br>).subscribe(<span class=\"hljs-keyword\">item</span>=&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">item</span>))<br>它会输出：<br><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure>\n\n<p>其中 of 称为创建器（creator），用来创建流，它返回一个 Observable 类型的对象，filter 和 map 称为操作符（operator），用来对条目进行处理。这些操作符被当作 Observable 对象的 pipe 方法的参数传进去。诚然，这个写法略显怪异，不过这主要是被 js 的设计缺陷所迫，它已经是目前 js 体系下多种解决方案中相对好看的一种了。<br>Observable 对象的 subscribe 方法表示消费者要订阅这个流，当流中出现数据时，传给 subscribe 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据。</p>\n<p><strong>注意，Observable 必须被 subscribe 之后才会开始生产数据。如果没人 subscribe 它，那就什么都不会做。</strong></p>\n<h5 id=\"四、rxjs和promise的区别\"><a href=\"#四、rxjs和promise的区别\" class=\"headerlink\" title=\"四、rxjs和promise的区别\"></a>四、rxjs和promise的区别</h5><p><img src=\"/images/rxjs/clipboard.png\" alt=\"image\"></p>\n<p>promise相较于Rxjs而言功能更单一 promise 只能将一个数据的状态由pending转换成resoloved或者rejected.而Rxjs可以处理多个数据对应complete和error状态但是Rxjs同时又拥有next方法。Observable是惰性的，需要subscribe的时候才输出值。promise内部状态是不可控制的，执行了就无法终止。而Observable可以定义如何取消异步方法。这也就是我下面会讨论到的一个异步场景。</p>\n<h5 id=\"五、详解\"><a href=\"#五、详解\" class=\"headerlink\" title=\"五、详解\"></a>五、详解</h5><h6 id=\"在-RxJS-中用来解决异步事件管理的的基本概念是：\"><a href=\"#在-RxJS-中用来解决异步事件管理的的基本概念是：\" class=\"headerlink\" title=\"在 RxJS 中用来解决异步事件管理的的基本概念是：\"></a>在 RxJS 中用来解决异步事件管理的的基本概念是：</h6><ol>\n<li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>\n<li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>\n<li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>\n<li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li>\n<li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>\n<li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li>\n</ol>\n<p><img src=\"/images/rxjs/clipboard2.png\" alt=\"image\"></p>\n<p>Observable 是同步的。</p>\n<p>函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。<br>Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。Observables 传递值可以是同步的，也可以是异步的。</p>\n<p>Observable 的核心关注点：</p>\n<ul>\n<li>创建 Observables</li>\n<li>订阅 Observables</li>\n<li>执行 Observables</li>\n<li>清理 Observables</li>\n</ul>\n","site":{"data":{}},"more":"<p>Rxjs：异步编程。angular已经集成了。</p>\n<h6 id=\"目前常见的异步编程的几种方法：\"><a href=\"#目前常见的异步编程的几种方法：\" class=\"headerlink\" title=\"目前常见的异步编程的几种方法：\"></a>目前常见的异步编程的几种方法：</h6><ol>\n<li>回调函数</li>\n<li>事件监听/发布订阅</li>\n<li>Promise</li>\n<li>Rxjs</li>\n</ol>\n<p><img src=\"/images/rxjs/clipboard3.png\" alt=\"image\"></p>\n<h5 id=\"前提：Promise-的缺点\"><a href=\"#前提：Promise-的缺点\" class=\"headerlink\" title=\"前提：Promise 的缺点\"></a>前提：Promise 的缺点</h5><p>Promise 固然是一个重大的进步，但在有些场景下仍然是不够的。比如，Promise 的特点是无论有没有人关心它的执行结果，它都会立即开始执行，并且你没有机会取消这次执行。显然，在某些情况下这么做是浪费的甚至错误的。仍然以电商为例，如果某商户的订单不允许取消，你还会去买吗？再举个编程领域的例子：如果你发起了一个 Ajax 请求，然后用户导航到了另一个路由，显然，你这个请求如果还没有完成就应该被取消，而不应该发出去。但是使用 Promise，你做不到，不是因为实现方面的原因，而是因为它在概念层（接口定义上）就无法支持取消。</p>\n<p>此外，由于 Promise 只会承载一个值，因此当我们要处理的是一个集合的时候就比较困难了。比如对于一个随机数列（总数未知），如果我们要借助 Web API 检查每个数字的有效性，然后对前一百个有效数字进行求和，那么用 Promise 写就比较麻烦了。<br>我们需要一个更高级的 Promise。</p>\n<h5 id=\"一、Observable\"><a href=\"#一、Observable\" class=\"headerlink\" title=\"一、Observable\"></a>一、Observable</h5><p>它就是可观察对象（Observable [əbˈzɜrvəbl]），Observable 顾名思义就是可以被别人观察的对象，当它变化时，观察者就可以得到通知。换句话说，它负责生产数据，别人可以消费它生产的数据。</p>\n<p>如果你是个资深后端，那么可能还记得 MessageQueue 的工作模式，它们很像。如果不懂 MQ 也没关系，我还是用日常知识给你打个比方。</p>\n<p>Observable 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人。</p>\n<p>整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可，简单、高效、无意外 —— 符合程序员的审美。</p>\n<p>而且这个生产线还非常先进 —— 不接单就不生产，非常有效地杜绝了浪费。</p>\n<h5 id=\"二、FRP\"><a href=\"#二、FRP\" class=\"headerlink\" title=\"二、FRP\"></a>二、FRP</h5><p>这种设计，看上去很美，对吧？但光看着漂亮可不行，在编程时要怎么实现呢？实际上，这是一种编程范式，叫做函数响应式编程（FRP）。它比 Promise 可年轻多了，直到 1997 年才被人提出来。</p>\n<p>顾名思义，FRP 同时具有函数式编程和响应式编程的特点。响应式编程是什么呢？形象的说，它的工作模式就是“饭来张口，衣来伸手”，也就是说，等待外界的输入，并做出响应。流水线每个工位上的工人正是这种工作模式。</p>\n<p>工业上，流水线是人类管理经验的结晶，它所做的事情是什么呢？本质上就是把每个处理都局部化，以减小复杂度（降低对工人素质的要求）。而这，正是软件行业所求之不得的。响应式，就是编程领域的流水线。</p>\n<p>那么函数式呢？函数式最显著的特征就是没有副作用，而这恰好是对流水线上每个工序的要求。显然，如果某个工序的操作会导致整个生产线平移 10 米，那么用不了多久这个生产线就要掉到海里了，这样的生产线毫无价值。<br>因此，响应式和函数式几乎是注定要在一起的。</p>\n<h5 id=\"三、RxJS\"><a href=\"#三、RxJS\" class=\"headerlink\" title=\"三、RxJS\"></a>三、RxJS</h5><p><strong>RXJS是Observable的Javascript实现</strong></p>\n<p>RxJS 就是 ReactiveX 在 JavaScript 语言上的实现。对于 JavaScript 程序员来说，不管你是前端还是 NodeJS 后端，RxJS 都会令你受益。<br>由于 JavaScript 本身的缺陷，RxJS 不得不采用了很多怪异的写法。它对于 Java / C# 等背景的程序员来说可能会显得比较怪异，不过，你可以先忽略它们，聚焦在编程范式和接下来要讲的操作符语义上。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">典型的写法<br><span class=\"hljs-keyword\">of</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>).pipe(<br>  <span class=\"hljs-built_in\">filter</span>(<span class=\"hljs-keyword\">item</span>=&gt;<span class=\"hljs-keyword\">item</span> % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">1</span>),<br>  map(<span class=\"hljs-keyword\">item</span>=&gt;<span class=\"hljs-keyword\">item</span> * <span class=\"hljs-number\">3</span>),<br>).subscribe(<span class=\"hljs-keyword\">item</span>=&gt; console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">item</span>))<br>它会输出：<br><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure>\n\n<p>其中 of 称为创建器（creator），用来创建流，它返回一个 Observable 类型的对象，filter 和 map 称为操作符（operator），用来对条目进行处理。这些操作符被当作 Observable 对象的 pipe 方法的参数传进去。诚然，这个写法略显怪异，不过这主要是被 js 的设计缺陷所迫，它已经是目前 js 体系下多种解决方案中相对好看的一种了。<br>Observable 对象的 subscribe 方法表示消费者要订阅这个流，当流中出现数据时，传给 subscribe 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据。</p>\n<p><strong>注意，Observable 必须被 subscribe 之后才会开始生产数据。如果没人 subscribe 它，那就什么都不会做。</strong></p>\n<h5 id=\"四、rxjs和promise的区别\"><a href=\"#四、rxjs和promise的区别\" class=\"headerlink\" title=\"四、rxjs和promise的区别\"></a>四、rxjs和promise的区别</h5><p><img src=\"/images/rxjs/clipboard.png\" alt=\"image\"></p>\n<p>promise相较于Rxjs而言功能更单一 promise 只能将一个数据的状态由pending转换成resoloved或者rejected.而Rxjs可以处理多个数据对应complete和error状态但是Rxjs同时又拥有next方法。Observable是惰性的，需要subscribe的时候才输出值。promise内部状态是不可控制的，执行了就无法终止。而Observable可以定义如何取消异步方法。这也就是我下面会讨论到的一个异步场景。</p>\n<h5 id=\"五、详解\"><a href=\"#五、详解\" class=\"headerlink\" title=\"五、详解\"></a>五、详解</h5><h6 id=\"在-RxJS-中用来解决异步事件管理的的基本概念是：\"><a href=\"#在-RxJS-中用来解决异步事件管理的的基本概念是：\" class=\"headerlink\" title=\"在 RxJS 中用来解决异步事件管理的的基本概念是：\"></a>在 RxJS 中用来解决异步事件管理的的基本概念是：</h6><ol>\n<li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>\n<li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>\n<li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>\n<li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li>\n<li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>\n<li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li>\n</ol>\n<p><img src=\"/images/rxjs/clipboard2.png\" alt=\"image\"></p>\n<p>Observable 是同步的。</p>\n<p>函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。<br>Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。Observables 传递值可以是同步的，也可以是异步的。</p>\n<p>Observable 的核心关注点：</p>\n<ul>\n<li>创建 Observables</li>\n<li>订阅 Observables</li>\n<li>执行 Observables</li>\n<li>清理 Observables</li>\n</ul>\n"},{"title":"package.json中dependencies 和 devDependencies 区别","date":"2019-05-10T09:34:20.000Z","excerpt":"package.json中dependencies 和 devDependencies 区别","position":null,"image_url":null,"_content":"- 当项目A发布到npm时，其他人npm install A时会一起下载A的dependencies，而A的devDependencies不会一起下载。\n- 对于项目A自己而言，npm install时都会下载，没什么区别。\n","source":"_posts/package.md","raw":"---\ntitle: package.json中dependencies 和 devDependencies 区别\ndate: 2019-05-10 17:34:20\nexcerpt: package.json中dependencies 和 devDependencies 区别\ntags: package\nposition:\nimage_url:\n---\n- 当项目A发布到npm时，其他人npm install A时会一起下载A的dependencies，而A的devDependencies不会一起下载。\n- 对于项目A自己而言，npm install时都会下载，没什么区别。\n","slug":"package","published":1,"updated":"2021-05-10T09:36:16.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojkne00151kwab2s34wb7","content":"<ul>\n<li>当项目A发布到npm时，其他人npm install A时会一起下载A的dependencies，而A的devDependencies不会一起下载。</li>\n<li>对于项目A自己而言，npm install时都会下载，没什么区别。</li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li>当项目A发布到npm时，其他人npm install A时会一起下载A的dependencies，而A的devDependencies不会一起下载。</li>\n<li>对于项目A自己而言，npm install时都会下载，没什么区别。</li>\n</ul>\n"},{"title":"ssh 免密码登录linux","date":"2019-07-08T09:56:40.000Z","excerpt":"ssh配置","_content":"\n假设：从A机器免密码跳转到B机器上，双方用户都要求是eshop\n\n一、登录到A机器\n     进入目录/home/eshop，运行ssh-keygen -t rsa\n     会生成 隐藏目录 .ssh , 在该目录下会有 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件\n\n\n二、B机器\n    复制A机器生成的id_rsa.pub（公钥）到/home/eshop/.ssh/id_rsa.pub\n    复制内容到 /home/eshop/.ssh/authorized_keys（如果没有就新建）中，命令：cat id_rsa.pub >> authorized_keys\n    修改authorized_keys权限为600，命令：chmod 600 authorized_keys\n    chmod 700 ~/.ssh/\n\n\n三、A机器\n    执行\n    ssh B机器ip\n    \n注：有时还得输密码配置，情况各异。\n可能情况参照：https://blog.csdn.net/u010180815/article/details/78323596\n","source":"_posts/ssh.md","raw":"---\ntitle: ssh 免密码登录linux\ndate: 2019-07-08 17:56:40\ntags: ssh\nexcerpt: ssh配置\n\n---\n\n假设：从A机器免密码跳转到B机器上，双方用户都要求是eshop\n\n一、登录到A机器\n     进入目录/home/eshop，运行ssh-keygen -t rsa\n     会生成 隐藏目录 .ssh , 在该目录下会有 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件\n\n\n二、B机器\n    复制A机器生成的id_rsa.pub（公钥）到/home/eshop/.ssh/id_rsa.pub\n    复制内容到 /home/eshop/.ssh/authorized_keys（如果没有就新建）中，命令：cat id_rsa.pub >> authorized_keys\n    修改authorized_keys权限为600，命令：chmod 600 authorized_keys\n    chmod 700 ~/.ssh/\n\n\n三、A机器\n    执行\n    ssh B机器ip\n    \n注：有时还得输密码配置，情况各异。\n可能情况参照：https://blog.csdn.net/u010180815/article/details/78323596\n","slug":"ssh","published":1,"updated":"2021-05-08T07:49:03.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknf00171kwa93tkg4ga","content":"<p>假设：从A机器免密码跳转到B机器上，双方用户都要求是eshop</p>\n<p>一、登录到A机器<br>     进入目录/home/eshop，运行ssh-keygen -t rsa<br>     会生成 隐藏目录 .ssh , 在该目录下会有 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件</p>\n<p>二、B机器<br>    复制A机器生成的id_rsa.pub（公钥）到/home/eshop/.ssh/id_rsa.pub<br>    复制内容到 /home/eshop/.ssh/authorized_keys（如果没有就新建）中，命令：cat id_rsa.pub &gt;&gt; authorized_keys<br>    修改authorized_keys权限为600，命令：chmod 600 authorized_keys<br>    chmod 700 ~/.ssh/</p>\n<p>三、A机器<br>    执行<br>    ssh B机器ip</p>\n<p>注：有时还得输密码配置，情况各异。<br>可能情况参照：<a href=\"https://blog.csdn.net/u010180815/article/details/78323596\">https://blog.csdn.net/u010180815/article/details/78323596</a></p>\n","site":{"data":{}},"more":"<p>假设：从A机器免密码跳转到B机器上，双方用户都要求是eshop</p>\n<p>一、登录到A机器<br>     进入目录/home/eshop，运行ssh-keygen -t rsa<br>     会生成 隐藏目录 .ssh , 在该目录下会有 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件</p>\n<p>二、B机器<br>    复制A机器生成的id_rsa.pub（公钥）到/home/eshop/.ssh/id_rsa.pub<br>    复制内容到 /home/eshop/.ssh/authorized_keys（如果没有就新建）中，命令：cat id_rsa.pub &gt;&gt; authorized_keys<br>    修改authorized_keys权限为600，命令：chmod 600 authorized_keys<br>    chmod 700 ~/.ssh/</p>\n<p>三、A机器<br>    执行<br>    ssh B机器ip</p>\n<p>注：有时还得输密码配置，情况各异。<br>可能情况参照：<a href=\"https://blog.csdn.net/u010180815/article/details/78323596\">https://blog.csdn.net/u010180815/article/details/78323596</a></p>\n"},{"title":"事件发布订阅","date":"2021-01-11T02:10:43.000Z","excerpt":"发布订阅","position":null,"image_url":null,"_content":"\n```\nclass Events {\n    constructor() {\n        this.events = new Map();\n    }\n\n    addEvent(key, fn, isOnce, ...args) {\n        const value = this.events.get(key) ? this.events.get(key) : this.events.set(key, new Map()).get(key)\n        value.set(fn, (...args1) => {\n            fn(...args, ...args1)\n            isOnce && this.off(key, fn)\n        })\n    }\n\n    on(key, fn, ...args) {\n        if (!fn) {\n            console.error(`没有传入回调函数`);\n            return\n        }\n        this.addEvent(key, fn, false, ...args)\n\n        console.log(this.events);\n    }\n\n    fire(key, ...args) {\n        if (!this.events.get(key)) {\n            console.warn(`没有 ${key} 事件`);\n            return;\n        }\n        for (let [, cb] of this.events.get(key).entries()) {\n            cb(...args);\n        }\n    }\n\n    off(key, fn) {\n        if (this.events.get(key)) {\n            this.events.get(key).delete(fn);\n        }\n    }\n\n    once(key, fn, ...args) {\n        this.addEvent(key, fn, true, ...args)\n    }\n}\n```\n\n思考：必须先订阅再发布吗？如何解决？\n```\n解决：我们可以加一个cache，保存历史新发布的消息记录，等新用户订阅时，直接执行。\nlist :{event:[client1,client2]}\ncache ：{event:[params1,params2,...]}\n\nvar Event = function () {\n  this.list = {}\n  this.cache = {}\n}\n\nEvent.prototype.add = function (area, client) {\n  if (!this.list[area]) this.list[area] = []\n  this.list[area].push(client)\n  this.cache[area].forEach(price => {\n    client.listen(area, price)\n  })\n}\n\nEvent.prototype.once = function (area, callback) {\n    let wrapFanc = (...args) => {//创建一个wrapFanc函数实现单次调用后停止监听\n        callback.apply(this.args)//执行wrapFanc\n        this.off(event,wrapFanc)//后停止监听事件\n   }\n\n    this.add(area,wrapFanc)\n\n  }\n  \nEvent.prototype.remove = function (area, client) {\n  if (!this.list[area]) return\n  var index = this.list[area].findIndex(item => item === client)\n  this.list[area].splice(index, 1)\n}\n\n\nEvent.prototype.triggle = function (area, price) {\n  if (!this.cache[area]) this.cache[area] = []\n  this.cache[area].push(price)\n\n  if (!this.list[area]) return\n  this.list[area].forEach(client => {\n    client.listen(area, price)\n  })\n}\n\nvar Client = function (name) {\n  this.name = name\n}\n\nClient.prototype.listen = function (area, price) {\n  console.log(`${this.name}收到${area}平的房源报价${price}`)\n}\n\n\nvar client1 = new Client('client1')\nvar client2 = new Client('client2')\n\n\nvar event = new Event()\n// event.add('80平', client1)\n// event.add('100平', client1)\n// event.add('80平', client2)\n// event.add('300平', client1)\n// event.remove('300平', client1)\n\nevent.triggle('80平', 200) // client1收到80平平的房源报价200 client2收到80平平的房源报价200\nevent.triggle('100平', 500) // client1收到100平平的房源报价500\nevent.triggle('200平', 1000) //\n\n\nvar client3 = new Client('client3')\nevent.add('80平', client3)\nevent.add('100平', client3)\n\nevent.add('80平', client1)\nevent.add('100平', client1)\n\nevent.triggle('80平', 1000) \n\n```\n","source":"_posts/subscribe.md","raw":"---\ntitle: 事件发布订阅\ndate: 2021-01-11 10:10:43\nexcerpt: 发布订阅\ntags: interview\nposition:\nimage_url:\n---\n\n```\nclass Events {\n    constructor() {\n        this.events = new Map();\n    }\n\n    addEvent(key, fn, isOnce, ...args) {\n        const value = this.events.get(key) ? this.events.get(key) : this.events.set(key, new Map()).get(key)\n        value.set(fn, (...args1) => {\n            fn(...args, ...args1)\n            isOnce && this.off(key, fn)\n        })\n    }\n\n    on(key, fn, ...args) {\n        if (!fn) {\n            console.error(`没有传入回调函数`);\n            return\n        }\n        this.addEvent(key, fn, false, ...args)\n\n        console.log(this.events);\n    }\n\n    fire(key, ...args) {\n        if (!this.events.get(key)) {\n            console.warn(`没有 ${key} 事件`);\n            return;\n        }\n        for (let [, cb] of this.events.get(key).entries()) {\n            cb(...args);\n        }\n    }\n\n    off(key, fn) {\n        if (this.events.get(key)) {\n            this.events.get(key).delete(fn);\n        }\n    }\n\n    once(key, fn, ...args) {\n        this.addEvent(key, fn, true, ...args)\n    }\n}\n```\n\n思考：必须先订阅再发布吗？如何解决？\n```\n解决：我们可以加一个cache，保存历史新发布的消息记录，等新用户订阅时，直接执行。\nlist :{event:[client1,client2]}\ncache ：{event:[params1,params2,...]}\n\nvar Event = function () {\n  this.list = {}\n  this.cache = {}\n}\n\nEvent.prototype.add = function (area, client) {\n  if (!this.list[area]) this.list[area] = []\n  this.list[area].push(client)\n  this.cache[area].forEach(price => {\n    client.listen(area, price)\n  })\n}\n\nEvent.prototype.once = function (area, callback) {\n    let wrapFanc = (...args) => {//创建一个wrapFanc函数实现单次调用后停止监听\n        callback.apply(this.args)//执行wrapFanc\n        this.off(event,wrapFanc)//后停止监听事件\n   }\n\n    this.add(area,wrapFanc)\n\n  }\n  \nEvent.prototype.remove = function (area, client) {\n  if (!this.list[area]) return\n  var index = this.list[area].findIndex(item => item === client)\n  this.list[area].splice(index, 1)\n}\n\n\nEvent.prototype.triggle = function (area, price) {\n  if (!this.cache[area]) this.cache[area] = []\n  this.cache[area].push(price)\n\n  if (!this.list[area]) return\n  this.list[area].forEach(client => {\n    client.listen(area, price)\n  })\n}\n\nvar Client = function (name) {\n  this.name = name\n}\n\nClient.prototype.listen = function (area, price) {\n  console.log(`${this.name}收到${area}平的房源报价${price}`)\n}\n\n\nvar client1 = new Client('client1')\nvar client2 = new Client('client2')\n\n\nvar event = new Event()\n// event.add('80平', client1)\n// event.add('100平', client1)\n// event.add('80平', client2)\n// event.add('300平', client1)\n// event.remove('300平', client1)\n\nevent.triggle('80平', 200) // client1收到80平平的房源报价200 client2收到80平平的房源报价200\nevent.triggle('100平', 500) // client1收到100平平的房源报价500\nevent.triggle('200平', 1000) //\n\n\nvar client3 = new Client('client3')\nevent.add('80平', client3)\nevent.add('100平', client3)\n\nevent.add('80平', client1)\nevent.add('100平', client1)\n\nevent.triggle('80平', 1000) \n\n```\n","slug":"subscribe","published":1,"updated":"2021-05-11T02:18:59.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknl001h1kwah03d00sm","content":"<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">class Events &#123;<br>    constructor() &#123;<br>        <span class=\"hljs-keyword\">this</span>.events = <span class=\"hljs-keyword\">new</span> Map();<br>    &#125;<br><br>    addEvent(<span class=\"hljs-built_in\">key</span>, fn, isOnce, ...args) &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>) ? <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>) : <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-built_in\">key</span>, <span class=\"hljs-keyword\">new</span> Map()).<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)<br>        value.<span class=\"hljs-built_in\">set</span>(fn, (...args1) =&gt; &#123;<br>            fn(...args, ...args1)<br>            isOnce &amp;&amp; <span class=\"hljs-keyword\">this</span>.off(<span class=\"hljs-built_in\">key</span>, fn)<br>        &#125;)<br>    &#125;<br><br>    on(<span class=\"hljs-built_in\">key</span>, fn, ...args) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!fn) &#123;<br>            console.error(`没有传入回调函数`);<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-keyword\">this</span>.addEvent(<span class=\"hljs-built_in\">key</span>, fn, <span class=\"hljs-keyword\">false</span>, ...args)<br><br>        console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">this</span>.events);<br>    &#125;<br><br>    fire(<span class=\"hljs-built_in\">key</span>, ...args) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)) &#123;<br>            console.warn(`没有 $&#123;<span class=\"hljs-built_in\">key</span>&#125; 事件`);<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (let [, cb] of <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>).entries()) &#123;<br>            cb(...args);<br>        &#125;<br>    &#125;<br><br>    off(<span class=\"hljs-built_in\">key</span>, fn) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)) &#123;<br>            <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>).delete(fn);<br>        &#125;<br>    &#125;<br><br>    once(<span class=\"hljs-built_in\">key</span>, fn, ...args) &#123;<br>        <span class=\"hljs-keyword\">this</span>.addEvent(<span class=\"hljs-built_in\">key</span>, fn, <span class=\"hljs-keyword\">true</span>, ...args)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思考：必须先订阅再发布吗？如何解决？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">解决：我们可以加一个cache，保存历史新发布的消息记录，等新用户订阅时，直接执行。<br><span class=\"hljs-attr\">list</span> :&#123;<span class=\"hljs-attr\">event</span>:[client1,client2]&#125;<br>cache ：&#123;<span class=\"hljs-attr\">event</span>:[params1,params2,...]&#125;<br><br><span class=\"hljs-keyword\">var</span> Event = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.list = &#123;&#125;<br>  <span class=\"hljs-built_in\">this</span>.cache = &#123;&#125;<br>&#125;<br><br>Event.prototype.add = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, client</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-built_in\">this</span>.list[area] = []<br>  <span class=\"hljs-built_in\">this</span>.list[area].push(client)<br>  <span class=\"hljs-built_in\">this</span>.cache[area].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">price</span> =&gt;</span> &#123;<br>    client.listen(area, price)<br>  &#125;)<br>&#125;<br><br>Event.prototype.once = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, callback</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> wrapFanc = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> &#123;<span class=\"hljs-comment\">//创建一个wrapFanc函数实现单次调用后停止监听</span><br>        callback.apply(<span class=\"hljs-built_in\">this</span>.args)<span class=\"hljs-comment\">//执行wrapFanc</span><br>        <span class=\"hljs-built_in\">this</span>.off(event,wrapFanc)<span class=\"hljs-comment\">//后停止监听事件</span><br>   &#125;<br><br>    <span class=\"hljs-built_in\">this</span>.add(area,wrapFanc)<br><br>  &#125;<br>  <br>Event.prototype.remove = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, client</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-built_in\">this</span>.list[area].findIndex(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item === client)<br>  <span class=\"hljs-built_in\">this</span>.list[area].splice(index, <span class=\"hljs-number\">1</span>)<br>&#125;<br><br><br>Event.prototype.triggle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, price</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.cache[area]) <span class=\"hljs-built_in\">this</span>.cache[area] = []<br>  <span class=\"hljs-built_in\">this</span>.cache[area].push(price)<br><br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-built_in\">this</span>.list[area].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>    client.listen(area, price)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> Client = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br>Client.prototype.listen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, price</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>收到<span class=\"hljs-subst\">$&#123;area&#125;</span>平的房源报价<span class=\"hljs-subst\">$&#123;price&#125;</span>`</span>)<br>&#125;<br><br><br><span class=\"hljs-keyword\">var</span> client1 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client1&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> client2 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client2&#x27;</span>)<br><br><br><span class=\"hljs-keyword\">var</span> event = <span class=\"hljs-keyword\">new</span> Event()<br><span class=\"hljs-comment\">// event.add(&#x27;80平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.add(&#x27;100平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.add(&#x27;80平&#x27;, client2)</span><br><span class=\"hljs-comment\">// event.add(&#x27;300平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.remove(&#x27;300平&#x27;, client1)</span><br><br>event.triggle(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, <span class=\"hljs-number\">200</span>) <span class=\"hljs-comment\">// client1收到80平平的房源报价200 client2收到80平平的房源报价200</span><br>event.triggle(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, <span class=\"hljs-number\">500</span>) <span class=\"hljs-comment\">// client1收到100平平的房源报价500</span><br>event.triggle(<span class=\"hljs-string\">&#x27;200平&#x27;</span>, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">//</span><br><br><br><span class=\"hljs-keyword\">var</span> client3 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client3&#x27;</span>)<br>event.add(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, client3)<br>event.add(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, client3)<br><br>event.add(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, client1)<br>event.add(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, client1)<br><br>event.triggle(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, <span class=\"hljs-number\">1000</span>) <br><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">class Events &#123;<br>    constructor() &#123;<br>        <span class=\"hljs-keyword\">this</span>.events = <span class=\"hljs-keyword\">new</span> Map();<br>    &#125;<br><br>    addEvent(<span class=\"hljs-built_in\">key</span>, fn, isOnce, ...args) &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>) ? <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>) : <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-built_in\">key</span>, <span class=\"hljs-keyword\">new</span> Map()).<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)<br>        value.<span class=\"hljs-built_in\">set</span>(fn, (...args1) =&gt; &#123;<br>            fn(...args, ...args1)<br>            isOnce &amp;&amp; <span class=\"hljs-keyword\">this</span>.off(<span class=\"hljs-built_in\">key</span>, fn)<br>        &#125;)<br>    &#125;<br><br>    on(<span class=\"hljs-built_in\">key</span>, fn, ...args) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!fn) &#123;<br>            console.error(`没有传入回调函数`);<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-keyword\">this</span>.addEvent(<span class=\"hljs-built_in\">key</span>, fn, <span class=\"hljs-keyword\">false</span>, ...args)<br><br>        console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">this</span>.events);<br>    &#125;<br><br>    fire(<span class=\"hljs-built_in\">key</span>, ...args) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)) &#123;<br>            console.warn(`没有 $&#123;<span class=\"hljs-built_in\">key</span>&#125; 事件`);<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (let [, cb] of <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>).entries()) &#123;<br>            cb(...args);<br>        &#125;<br>    &#125;<br><br>    off(<span class=\"hljs-built_in\">key</span>, fn) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>)) &#123;<br>            <span class=\"hljs-keyword\">this</span>.events.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">key</span>).delete(fn);<br>        &#125;<br>    &#125;<br><br>    once(<span class=\"hljs-built_in\">key</span>, fn, ...args) &#123;<br>        <span class=\"hljs-keyword\">this</span>.addEvent(<span class=\"hljs-built_in\">key</span>, fn, <span class=\"hljs-keyword\">true</span>, ...args)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>思考：必须先订阅再发布吗？如何解决？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">解决：我们可以加一个cache，保存历史新发布的消息记录，等新用户订阅时，直接执行。<br><span class=\"hljs-attr\">list</span> :&#123;<span class=\"hljs-attr\">event</span>:[client1,client2]&#125;<br>cache ：&#123;<span class=\"hljs-attr\">event</span>:[params1,params2,...]&#125;<br><br><span class=\"hljs-keyword\">var</span> Event = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.list = &#123;&#125;<br>  <span class=\"hljs-built_in\">this</span>.cache = &#123;&#125;<br>&#125;<br><br>Event.prototype.add = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, client</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-built_in\">this</span>.list[area] = []<br>  <span class=\"hljs-built_in\">this</span>.list[area].push(client)<br>  <span class=\"hljs-built_in\">this</span>.cache[area].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">price</span> =&gt;</span> &#123;<br>    client.listen(area, price)<br>  &#125;)<br>&#125;<br><br>Event.prototype.once = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, callback</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> wrapFanc = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> &#123;<span class=\"hljs-comment\">//创建一个wrapFanc函数实现单次调用后停止监听</span><br>        callback.apply(<span class=\"hljs-built_in\">this</span>.args)<span class=\"hljs-comment\">//执行wrapFanc</span><br>        <span class=\"hljs-built_in\">this</span>.off(event,wrapFanc)<span class=\"hljs-comment\">//后停止监听事件</span><br>   &#125;<br><br>    <span class=\"hljs-built_in\">this</span>.add(area,wrapFanc)<br><br>  &#125;<br>  <br>Event.prototype.remove = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, client</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-built_in\">this</span>.list[area].findIndex(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item === client)<br>  <span class=\"hljs-built_in\">this</span>.list[area].splice(index, <span class=\"hljs-number\">1</span>)<br>&#125;<br><br><br>Event.prototype.triggle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, price</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.cache[area]) <span class=\"hljs-built_in\">this</span>.cache[area] = []<br>  <span class=\"hljs-built_in\">this</span>.cache[area].push(price)<br><br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.list[area]) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-built_in\">this</span>.list[area].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>    client.listen(area, price)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> Client = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br>Client.prototype.listen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">area, price</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>收到<span class=\"hljs-subst\">$&#123;area&#125;</span>平的房源报价<span class=\"hljs-subst\">$&#123;price&#125;</span>`</span>)<br>&#125;<br><br><br><span class=\"hljs-keyword\">var</span> client1 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client1&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> client2 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client2&#x27;</span>)<br><br><br><span class=\"hljs-keyword\">var</span> event = <span class=\"hljs-keyword\">new</span> Event()<br><span class=\"hljs-comment\">// event.add(&#x27;80平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.add(&#x27;100平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.add(&#x27;80平&#x27;, client2)</span><br><span class=\"hljs-comment\">// event.add(&#x27;300平&#x27;, client1)</span><br><span class=\"hljs-comment\">// event.remove(&#x27;300平&#x27;, client1)</span><br><br>event.triggle(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, <span class=\"hljs-number\">200</span>) <span class=\"hljs-comment\">// client1收到80平平的房源报价200 client2收到80平平的房源报价200</span><br>event.triggle(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, <span class=\"hljs-number\">500</span>) <span class=\"hljs-comment\">// client1收到100平平的房源报价500</span><br>event.triggle(<span class=\"hljs-string\">&#x27;200平&#x27;</span>, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">//</span><br><br><br><span class=\"hljs-keyword\">var</span> client3 = <span class=\"hljs-keyword\">new</span> Client(<span class=\"hljs-string\">&#x27;client3&#x27;</span>)<br>event.add(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, client3)<br>event.add(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, client3)<br><br>event.add(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, client1)<br>event.add(<span class=\"hljs-string\">&#x27;100平&#x27;</span>, client1)<br><br>event.triggle(<span class=\"hljs-string\">&#x27;80平&#x27;</span>, <span class=\"hljs-number\">1000</span>) <br><br></code></pre></td></tr></table></figure>\n"},{"title":"weakSet和weakMap","date":"2021-04-23T10:11:47.000Z","excerpt":"weakSet和weakMap","position":null,"image_url":null,"_content":"### weakSet 和 Set 对象的区别有两点:\n1. WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.\n2. WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素\n\n\n>WeakSet 不能被遍历，也没有size属性。\n","source":"_posts/weakSet.md","raw":"---\ntitle: weakSet和weakMap\ndate: 2021-04-23 18:11:47\nexcerpt: weakSet和weakMap\ntags: es6\nposition:\nimage_url:\n---\n### weakSet 和 Set 对象的区别有两点:\n1. WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.\n2. WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素\n\n\n>WeakSet 不能被遍历，也没有size属性。\n","slug":"weakSet","published":1,"updated":"2021-05-11T01:57:29.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknl001i1kwa6pix9mcx","content":"<h3 id=\"weakSet-和-Set-对象的区别有两点\"><a href=\"#weakSet-和-Set-对象的区别有两点\" class=\"headerlink\" title=\"weakSet 和 Set 对象的区别有两点:\"></a>weakSet 和 Set 对象的区别有两点:</h3><ol>\n<li>WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.</li>\n<li>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素</li>\n</ol>\n<blockquote>\n<p>WeakSet 不能被遍历，也没有size属性。</p>\n</blockquote>\n","site":{"data":{}},"more":"<h3 id=\"weakSet-和-Set-对象的区别有两点\"><a href=\"#weakSet-和-Set-对象的区别有两点\" class=\"headerlink\" title=\"weakSet 和 Set 对象的区别有两点:\"></a>weakSet 和 Set 对象的区别有两点:</h3><ol>\n<li>WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.</li>\n<li>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素</li>\n</ol>\n<blockquote>\n<p>WeakSet 不能被遍历，也没有size属性。</p>\n</blockquote>\n"},{"title":"webpack自定义插件","date":"2020-07-20T08:11:03.000Z","excerpt":"webpack自定义插件","position":null,"image_url":null,"_content":"## webpack构建流程：\n1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\n1. 开始编译：用上一步得到的参数初始化 Compiler 对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，他包含了webpack的module、plugin等参数信息。执行对象的 run 方法开始执行编译；\n1. 确定入口：根据配置中的 entry 找出所有的入口文件；\n1. 创建compilation对象：可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。\n1. 翻译模块：通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST（抽象语法树）,当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归处理所有的依赖。\n1. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n1. 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n\n\n## 一个典型的Webpack插件代码如下：\n```\n// 插件代码\nclass MyWebpackPlugin {\n  constructor(options) {\n  }\n  \n  apply(compiler) {\n    // 在emit阶段插入钩子函数\n    compiler.hooks.emit.tap('MyWebpackPlugin', (compilation) => {});\n    \n   // \n   compileer.hooks.阶段.tap函数('插件名称', (阶段回调参数) => {\n  \n   });\n  }\n}\n\nmodule.exports = MyWebpackPlugin;apply方法中插入钩子的一般形式如下：\n```\n\n##### 常见钩子\nWebpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。\n\n钩子 | 说明 | 参数 | 类型\n---|---|---|---\nafterPlugins | 启动一次新的编译 | compiler | 同步\ncompile | 创建compilation对象之前 | compilationParams | 同步\ncompilation | compilation对象创建完成 | compilation | 同步\nemit | 资源生成完成，输出之前 | compilation | 异步\nafterEmit | 资源输出到目录完成 | compilation | 异步\ndone | 完成编译 | stats | 同步\n\n\n\n## Tapable\n> Tapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。\n- tap 同步钩子\n- tapAsync 异步钩子，通过callback回调告诉Webpack异步执行完毕\n- tapPromise 异步钩子，返回一个Promise告诉Webpack异步执行完毕\n","source":"_posts/webpack-custom-plugin.md","raw":"---\ntitle: webpack自定义插件\ndate: 2020-07-20 16:11:03\nexcerpt: webpack自定义插件\ntags: webpack\nposition:\nimage_url:\n---\n## webpack构建流程：\n1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\n1. 开始编译：用上一步得到的参数初始化 Compiler 对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，他包含了webpack的module、plugin等参数信息。执行对象的 run 方法开始执行编译；\n1. 确定入口：根据配置中的 entry 找出所有的入口文件；\n1. 创建compilation对象：可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。\n1. 翻译模块：通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST（抽象语法树）,当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归处理所有的依赖。\n1. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n1. 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n\n\n## 一个典型的Webpack插件代码如下：\n```\n// 插件代码\nclass MyWebpackPlugin {\n  constructor(options) {\n  }\n  \n  apply(compiler) {\n    // 在emit阶段插入钩子函数\n    compiler.hooks.emit.tap('MyWebpackPlugin', (compilation) => {});\n    \n   // \n   compileer.hooks.阶段.tap函数('插件名称', (阶段回调参数) => {\n  \n   });\n  }\n}\n\nmodule.exports = MyWebpackPlugin;apply方法中插入钩子的一般形式如下：\n```\n\n##### 常见钩子\nWebpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。\n\n钩子 | 说明 | 参数 | 类型\n---|---|---|---\nafterPlugins | 启动一次新的编译 | compiler | 同步\ncompile | 创建compilation对象之前 | compilationParams | 同步\ncompilation | compilation对象创建完成 | compilation | 同步\nemit | 资源生成完成，输出之前 | compilation | 异步\nafterEmit | 资源输出到目录完成 | compilation | 异步\ndone | 完成编译 | stats | 同步\n\n\n\n## Tapable\n> Tapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。\n- tap 同步钩子\n- tapAsync 异步钩子，通过callback回调告诉Webpack异步执行完毕\n- tapPromise 异步钩子，返回一个Promise告诉Webpack异步执行完毕\n","slug":"webpack-custom-plugin","published":1,"updated":"2021-05-10T08:32:42.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknm001k1kwab4r8bsm6","content":"<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><ol>\n<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>\n<li>开始编译：用上一步得到的参数初始化 Compiler 对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，他包含了webpack的module、plugin等参数信息。执行对象的 run 方法开始执行编译；</li>\n<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>\n<li>创建compilation对象：可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。</li>\n<li>翻译模块：通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST（抽象语法树）,当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归处理所有的依赖。</li>\n<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>\n<li>在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>\n</ol>\n<h2 id=\"一个典型的Webpack插件代码如下：\"><a href=\"#一个典型的Webpack插件代码如下：\" class=\"headerlink\" title=\"一个典型的Webpack插件代码如下：\"></a>一个典型的Webpack插件代码如下：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 插件代码</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyWebpackPlugin</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">options</span>)</span> &#123;<br>  &#125;<br>  <br>  <span class=\"hljs-function\"><span class=\"hljs-title\">apply</span>(<span class=\"hljs-params\">compiler</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 在emit阶段插入钩子函数</span><br>    compiler.hooks.emit.tap(<span class=\"hljs-string\">&#x27;MyWebpackPlugin&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">compilation</span>) =&gt;</span> &#123;&#125;);<br>    <br>   <span class=\"hljs-comment\">// </span><br>   compileer.hooks.阶段.tap函数(<span class=\"hljs-string\">&#x27;插件名称&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">阶段回调参数</span>) =&gt;</span> &#123;<br>  <br>   &#125;);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">module</span>.exports = MyWebpackPlugin;apply方法中插入钩子的一般形式如下：<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"常见钩子\"><a href=\"#常见钩子\" class=\"headerlink\" title=\"常见钩子\"></a>常见钩子</h5><p>Webpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。</p>\n<table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>说明</th>\n<th>参数</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>afterPlugins</td>\n<td>启动一次新的编译</td>\n<td>compiler</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>compile</td>\n<td>创建compilation对象之前</td>\n<td>compilationParams</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>compilation</td>\n<td>compilation对象创建完成</td>\n<td>compilation</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>emit</td>\n<td>资源生成完成，输出之前</td>\n<td>compilation</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>afterEmit</td>\n<td>资源输出到目录完成</td>\n<td>compilation</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>done</td>\n<td>完成编译</td>\n<td>stats</td>\n<td>同步</td>\n</tr>\n</tbody></table>\n<h2 id=\"Tapable\"><a href=\"#Tapable\" class=\"headerlink\" title=\"Tapable\"></a>Tapable</h2><blockquote>\n<p>Tapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。</p>\n</blockquote>\n<ul>\n<li>tap 同步钩子</li>\n<li>tapAsync 异步钩子，通过callback回调告诉Webpack异步执行完毕</li>\n<li>tapPromise 异步钩子，返回一个Promise告诉Webpack异步执行完毕</li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><ol>\n<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>\n<li>开始编译：用上一步得到的参数初始化 Compiler 对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，他包含了webpack的module、plugin等参数信息。执行对象的 run 方法开始执行编译；</li>\n<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>\n<li>创建compilation对象：可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。</li>\n<li>翻译模块：通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST（抽象语法树）,当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归处理所有的依赖。</li>\n<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>\n<li>在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>\n</ol>\n<h2 id=\"一个典型的Webpack插件代码如下：\"><a href=\"#一个典型的Webpack插件代码如下：\" class=\"headerlink\" title=\"一个典型的Webpack插件代码如下：\"></a>一个典型的Webpack插件代码如下：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 插件代码</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyWebpackPlugin</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">options</span>)</span> &#123;<br>  &#125;<br>  <br>  <span class=\"hljs-function\"><span class=\"hljs-title\">apply</span>(<span class=\"hljs-params\">compiler</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 在emit阶段插入钩子函数</span><br>    compiler.hooks.emit.tap(<span class=\"hljs-string\">&#x27;MyWebpackPlugin&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">compilation</span>) =&gt;</span> &#123;&#125;);<br>    <br>   <span class=\"hljs-comment\">// </span><br>   compileer.hooks.阶段.tap函数(<span class=\"hljs-string\">&#x27;插件名称&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">阶段回调参数</span>) =&gt;</span> &#123;<br>  <br>   &#125;);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">module</span>.exports = MyWebpackPlugin;apply方法中插入钩子的一般形式如下：<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"常见钩子\"><a href=\"#常见钩子\" class=\"headerlink\" title=\"常见钩子\"></a>常见钩子</h5><p>Webpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。</p>\n<table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>说明</th>\n<th>参数</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>afterPlugins</td>\n<td>启动一次新的编译</td>\n<td>compiler</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>compile</td>\n<td>创建compilation对象之前</td>\n<td>compilationParams</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>compilation</td>\n<td>compilation对象创建完成</td>\n<td>compilation</td>\n<td>同步</td>\n</tr>\n<tr>\n<td>emit</td>\n<td>资源生成完成，输出之前</td>\n<td>compilation</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>afterEmit</td>\n<td>资源输出到目录完成</td>\n<td>compilation</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>done</td>\n<td>完成编译</td>\n<td>stats</td>\n<td>同步</td>\n</tr>\n</tbody></table>\n<h2 id=\"Tapable\"><a href=\"#Tapable\" class=\"headerlink\" title=\"Tapable\"></a>Tapable</h2><blockquote>\n<p>Tapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。</p>\n</blockquote>\n<ul>\n<li>tap 同步钩子</li>\n<li>tapAsync 异步钩子，通过callback回调告诉Webpack异步执行完毕</li>\n<li>tapPromise 异步钩子，返回一个Promise告诉Webpack异步执行完毕</li>\n</ul>\n"},{"title":"webpack分析打包大小","date":"2020-07-29T08:32:34.000Z","excerpt":"webpack分析打包大小","position":null,"image_url":null,"_content":"```\n1、安装插件\nnpm install --save-dev webpack-bundle-analyzer\n\n2、打包\nng build --prod --stats-json\n\n3、启动\nnpm run bundle-report\n```\n","source":"_posts/webpack-analyzer.md","raw":"---\ntitle: webpack分析打包大小\ndate: 2020-07-29 16:32:34\nexcerpt: webpack分析打包大小\ntags: webpack\nposition:\nimage_url:\n---\n```\n1、安装插件\nnpm install --save-dev webpack-bundle-analyzer\n\n2、打包\nng build --prod --stats-json\n\n3、启动\nnpm run bundle-report\n```\n","slug":"webpack-analyzer","published":1,"updated":"2021-05-10T08:33:42.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojojknn001m1kwaas9gex0e","content":"<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-number\">1</span>、安装插件<br><span class=\"hljs-title\">npm</span> install <span class=\"hljs-comment\">--save-dev webpack-bundle-analyzer</span><br><br><span class=\"hljs-number\">2</span>、打包<br><span class=\"hljs-title\">ng</span> build <span class=\"hljs-comment\">--prod --stats-json</span><br><br><span class=\"hljs-number\">3</span>、启动<br><span class=\"hljs-title\">npm</span> run bundle-re<span class=\"hljs-keyword\">port</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"more":"<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-number\">1</span>、安装插件<br><span class=\"hljs-title\">npm</span> install <span class=\"hljs-comment\">--save-dev webpack-bundle-analyzer</span><br><br><span class=\"hljs-number\">2</span>、打包<br><span class=\"hljs-title\">ng</span> build <span class=\"hljs-comment\">--prod --stats-json</span><br><br><span class=\"hljs-number\">3</span>、启动<br><span class=\"hljs-title\">npm</span> run bundle-re<span class=\"hljs-keyword\">port</span><br></code></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckojojkmr000b1kwa0o3q88m0","category_id":"ckojojkmx000e1kwa12u19gig","_id":"ckojojkn3000n1kwaf69oh74f"}],"PostTag":[{"post_id":"ckojojkmp000a1kwa9aag3cr1","tag_id":"ckojojkms000c1kwab4a5dgrx","_id":"ckojojkn0000i1kwags506dtv"},{"post_id":"ckojojkmr000b1kwa0o3q88m0","tag_id":"ckojojkn0000h1kwa2asa17lx","_id":"ckojojkn3000o1kwad3il4dge"},{"post_id":"ckojojkmv000d1kwa016vdsk9","tag_id":"ckojojkn2000l1kwa1j0ycybw","_id":"ckojojkn6000s1kwa5bxt7rei"},{"post_id":"ckojojkmz000g1kwa2rqce7qf","tag_id":"ckojojkn5000q1kwa6lmi7mwx","_id":"ckojojkn9000w1kwa8odx70aw"},{"post_id":"ckojojkn0000j1kwabr2jcj9w","tag_id":"ckojojkn2000l1kwa1j0ycybw","_id":"ckojojknb00101kwa0b9ram7h"},{"post_id":"ckojojknb00111kwacckvffyj","tag_id":"ckojojkms000c1kwab4a5dgrx","_id":"ckojojknd00141kwa4fyd60hf"},{"post_id":"ckojojkn2000m1kwag7lj2xft","tag_id":"ckojojkna000y1kwa2i26ai9m","_id":"ckojojkne00161kwage8vdnpr"},{"post_id":"ckojojkn3000p1kwa2auu78nx","tag_id":"ckojojknd00131kwa0uye6quw","_id":"ckojojkng00191kwa130fdn3u"},{"post_id":"ckojojkna000z1kwabfit8pol","tag_id":"ckojojknf00181kwa5b8178g0","_id":"ckojojkni001b1kwag2kw8g4i"},{"post_id":"ckojojknc00121kwaao20ay60","tag_id":"ckojojkng001a1kwaa26l7c6s","_id":"ckojojknj001d1kwagwqf3136"},{"post_id":"ckojojkne00151kwab2s34wb7","tag_id":"ckojojkni001c1kwa6knsftnw","_id":"ckojojknj001f1kwa7zme5njr"},{"post_id":"ckojojknf00171kwa93tkg4ga","tag_id":"ckojojknj001e1kwa4ml507fp","_id":"ckojojknj001g1kwa5hig2d3s"},{"post_id":"ckojojknl001h1kwah03d00sm","tag_id":"ckojojkn0000h1kwa2asa17lx","_id":"ckojojknm001j1kwa9h9fet8j"},{"post_id":"ckojojknl001i1kwa6pix9mcx","tag_id":"ckojojknd00131kwa0uye6quw","_id":"ckojojknn001l1kwa4d4w2vd4"},{"post_id":"ckojojknm001k1kwab4r8bsm6","tag_id":"ckojojknn001n1kwag4bh8wio","_id":"ckojojkno001p1kwa7o0d4vc0"},{"post_id":"ckojojknn001m1kwaas9gex0e","tag_id":"ckojojknn001n1kwag4bh8wio","_id":"ckojojkno001q1kwahhgy6s65"}],"Tag":[{"name":"js","_id":"ckojojkms000c1kwab4a5dgrx"},{"name":"interview","_id":"ckojojkn0000h1kwa2asa17lx"},{"name":"css","_id":"ckojojkn2000l1kwa1j0ycybw"},{"name":"重排,重绘","_id":"ckojojkn5000q1kwa6lmi7mwx"},{"name":"offsetWidth,clientWidth,scrollWidth","_id":"ckojojkna000y1kwa2i26ai9m"},{"name":"es6","_id":"ckojojknd00131kwa0uye6quw"},{"name":"linux","_id":"ckojojknf00181kwa5b8178g0"},{"name":"rxjs","_id":"ckojojkng001a1kwaa26l7c6s"},{"name":"package","_id":"ckojojkni001c1kwa6knsftnw"},{"name":"ssh","_id":"ckojojknj001e1kwa4ml507fp"},{"name":"webpack","_id":"ckojojknn001n1kwag4bh8wio"}]}}